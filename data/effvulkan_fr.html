<!DOCTYPE html>
<!-- saved from url=(0091)https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html -->
<html lang="fr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
          <title>Écrire un moteur de rendu Vulkan performant</title>
        
        <meta name="author" content="Fevrier Dorian">
        <meta name="generator" content="Pelican">
        <link rel="stylesheet" type="text/css" href="./effvulkan_fr_files/main.css">
        <link href="https://www.fevrierdorian.com/carnet/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="FdCarnet Full Atom Feed">


</head>

<body id="index" class="home">
    <!--<header id="banner" class="body">
        <h1><a href="https://www.fevrierdorian.com/carnet/">FdCarnet</a></h1>
    </header><!-- /#banner -->
    <div id="left-panel">
    <banner id="fd-carnet-logo"><a href="https://www.fevrierdorian.com/carnet/pages/accueil.html" title="FdCarnet"></a></banner>
    <nav id="menu">
        <ul>
            <li><a href="https://www.fevrierdorian.com/carnet/pages/accueil.html">Accueil</a></li>
            <li><a href="https://www.fevrierdorian.com/carnet/all_pages.html">Toutes les pages</a></li>
        </ul>
    </nav><!-- /#menu -->
    </div><!-- /#left-panel -->
    <main id="content">
    <h1>Écrire un moteur de rendu Vulkan performant</h1>
    

    <div class="toc">
<ul>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#avant-propos">Avant-propos</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#introduction">Introduction</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#resume">Résumé</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#gestion-de-la-memoire">Gestion de la mémoire</a><ul>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#selection-de-la-memoire-de-tas">Sélection de la mémoire de tas</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#sous-allocation-de-la-memoire">Sous-allocation de la mémoire</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#allocations-dediees">Allocations dédiées</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#mappage-de-la-memoire">Mappage de la mémoire</a></li>
</ul>
</li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#sets-de-descripteurs">Sets de descripteurs</a><ul>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#modele-mental">Modèle mental</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#gestion-des-sets-de-descripteurs-dynamiques">Gestion des sets de descripteurs dynamiques</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#choisir-le-bon-type-de-descripteurs">Choisir le bon type de descripteurs</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#binding-par-emplacement">Binding par emplacement</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#sets-de-descripteurs-par-frequence">Sets de descripteurs par fréquence</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#conceptions-de-descripteurs-bindless">Conceptions de descripteurs bindless</a></li>
</ul>
</li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#enregistrement-et-soumission-de-command-buffers">Enregistrement et soumission de command buffers</a><ul>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#modele-mental_1">Modèle mental</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#enregistrement-des-commandes-multi-threade">Enregistrement des commandes multi-threadé</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#soumission-des-command-buffers">Soumission des command buffers</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#les-command-buffers-secondaires">Les Command buffers secondaires</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#reutilisation-des-command-buffers">Réutilisation des command buffers</a></li>
</ul>
</li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#barrieres-de-pipeline">Barrières de pipeline</a><ul>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#modele-mental_2">Modèle mental</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#obtenir-les-meilleures-performances">Obtenir les meilleures performances</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#simplifier-la-specification-des-barrieres">Simplifier la spécification des barrières</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#predire-lavenir-avec-des-graphs-de-rendu">Prédire l’avenir avec des graphs de rendu</a></li>
</ul>
</li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#les-passes-de-rendu">Les passes de rendu</a><ul>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#les-operations-load-et-store">Les opérations load et store</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#resolution-rapide-du-msaa">Résolution rapide du MSAA</a></li>
</ul>
</li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#les-pipeline-objects">Les pipeline objects</a><ul>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#compilation-a-la-volee">Compilation à-la-volée</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#cache-de-pipeline-et-prechauffage-du-cache">Cache de pipeline et préchauffage du cache</a></li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#compilation-davance">Compilation d’avance</a></li>
</ul>
</li>
<li><a href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#conclusion">Conclusion</a></li>
</ul>
</div>
<h2 id="avant-propos">Avant-propos</h2>
<p>Ceci est une traduction de l’article de Arseny Kapoulkine du 27 février 2020 : <a href="https://zeux.io/2020/02/27/writing-an-efficient-vulkan-renderer/">Writing an efficient Vulkan renderer</a>. Vous pouvez retrouver sa chaîne Youtube <a href="https://www.youtube.com/c/zeuxcg/videos">ici</a>.</p>
<h2 id="introduction">Introduction</h2>
<p>En 2018, j’ai écrit « Écrire un moteur de rendu Vulkan performant » pour le livre GPU Zen 2, qui a été publié en 2019. Dans cet article, j’ai essayé de rassembler autant d’informations que possible sur les performances de Vulkan — au lieu de se concentrer sur un aspect ou une application particulière, il tente de couvrir un large éventail de sujets, permettant aux lecteurs de comprendre le comportement des différentes APIs sur du matériel réel et fournir un panel d’options pour chaque problème à résoudre.</p>
<p>Au moment de la publication de cet article, l’<a href="https://www.amazon.fr/GPU-Zen-Advanced-Rendering-Techniques-ebook/dp/B07SYP7P6B">édition Kindle du livre</a> est disponible pour 2,99 € sur Amazon — c’est moins cher qu’une tasse de café et ça vaut vraiment le coup<sup id="fnref:1"><a class="footnote-ref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fn:1">1</a></sup>. Il contient de nombreux articles intéressants sur le rendu d’effets et la conception.</p>
<p>Vous avez ici la copie complète et gratuite de l’article — j’espère qu’elle aidera les développeurs graphiques à comprendre et utiliser Vulkan au maximum de ses capacités. L’article a été légèrement modifié pour mentionner les améliorations de Vulkan 1.1/1.2 quand c’était nécessaire — heureusement, peu de choses impactant les performances ont changé au cours des deux dernières années, le contenu devrait donc toujours être d’actualité.</p>
<p>Bonne lecture !</p>
<h2 id="resume">Résumé</h2>
<p>Vulkan est une nouvelle API graphique, explicite et multi-plateforme. Elle introduit beaucoup de nouveaux concepts pouvant rebuter les développeurs graphiques les plus aguerris. Vulkan se focalise sur les performances — cependant, atteindre de bonnes performances nécessite une connaissance approfondie de ces concepts et de la manière de les appliquer efficacement, ainsi que de leur implémentation dans chaque pilote. Cet article abordera des thèmes tels que l’allocation de la mémoire, la gestion des sets de descripteurs, l’enregistrement des <em>command buffers</em>, les barrières de pipeline, les passes de rendu et discutera des moyens d’optimiser les performances CPU et GPU des moteurs de rendu Vulkan bureau/mobiles d’aujourd’hui, ainsi que ce qu’un moteur de rendu Vulkan pourrait faire différemment à l’avenir.</p>
<p>Les moteurs de rendu modernes deviennent de plus en plus complexes et doivent prendre en charge de nombreuses API graphiques, chacune ayant des niveaux d’abstraction matérielle différents et des ensembles de concepts disjoints. Cela rend parfois difficile la prise en charge de toutes les plates-formes avec le même niveau d’efficacité. Heureusement, pour la plupart des tâches, Vulkan propose plusieurs options allant de la simple réimplémentation de concepts venant d’autres API de façon plus précise, car codé spécifiquement pour les besoins du moteur, à la difficile refonte de gros systèmes pour les rendre optimaux avec Vulkan. Nous essaierons de couvrir les deux extrêmes quand cela est possible — au final, c’est un compromis entre l’efficacité maximale d’un système compatibles Vulkan et les coûts d’implémentation et de maintenance propre à chaque moteur. De plus, l’efficacité dépend souvent de l’application — les conseils de cet article sont génériques et c’est en prenant des décisions d’implémentation à la lueur de résultats de profilage d’une application précise sur une plateforme précise qu’on obtient les meilleures performances.</p>
<p>Cet article suppose que le lecteur est familiarisé avec les bases de l’API Vulkan et souhaite mieux les comprendre et/ou apprendre à utiliser l’API efficacement.</p>
<h2 id="gestion-de-la-memoire">Gestion de la mémoire</h2>
<p>La gestion de la mémoire reste un sujet extrêmement complexe, et il l’est encore plus dans Vulkan en raison de la diversité de configurations du tas des différents matériels. Les API antérieures adoptaient un concept « centré sur les ressources » — le développeur n’a pas de concept de <em>mémoire</em> graphique, mais uniquement celui de <em>ressource</em> graphique, et chaque pilote est libre de gérer la mémoire des ressources en fonction des indicateurs d’utilisation des API et d’un ensemble d’heuristiques. À l’inverse, Vulkan, oblige à réfléchir à la gestion de la mémoire dès le départ, car vous devez allouer manuellement de la mémoire pour créer des ressources.</p>
<p>Une première étape parfaitement raisonnable consiste à intégrer <code>VulkanMemoryAllocator</code> (désormais abrégé en VMA), une bibliothèque open-source développée par AMD qui résout certains détails de gestion de la mémoire pour vous, en fournissant un allocateur de ressources à usage général au-dessus des fonctions Vulkan. Même si vous utilisez cette bibliothèque, certaines considérations de performances s’appliquent toujours ; le reste de cette section passera en revue les pièges de gestion de la mémoire, sans supposer que vous utilisez VMA ; mais tous les conseils s’appliquent également à VMA.</p>
<h3 id="selection-de-la-memoire-de-tas">Sélection de la mémoire de tas</h3>
<p>Lors de la création d’une ressource dans Vulkan, vous devez choisir un tas à partir duquel allouer de la mémoire. Le dispositif Vulkan expose un ensemble de types de mémoire dont chacun a des indicateurs qui définissent le comportement de cette mémoire et un index de tas définissant la taille disponible.</p>
<p>La plupart des implémentations de Vulkan exposent deux ou trois des combinaisons d’indicateurs suivantes<sup id="fnref:2"><a class="footnote-ref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fn:2">2</a></sup> :</p>
<ul>
<li>
<p><code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> — fait généralement référence à la mémoire GPU qui n’est pas directement visible depuis le CPU ; il est plus rapide d’y accéder à partir du GPU et c’est la mémoire que vous devriez utiliser pour stocker toutes les cibles de rendu, les ressources propres au GPU telles que les <em>compute buffers</em>, ainsi que toutes les ressources statiques telles que les buffers de textures et de géométries.</p>
</li>
<li>
<p><code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> — sur le matériel AMD, ce type de mémoire fait référence à de la mémoire vidéo (jusqu’à 256 Mo) sur laquelle le CPU peut écrire directement, et qui est parfaite pour allouer des quantités raisonnables de données écrites par le CPU à chaque image, telles que les <em>uniform buffers</em> ou les <em>vertex/index buffers</em> dynamiques.</p>
</li>
<li>
<p><code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code><sup id="fnref:3"><a class="footnote-ref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fn:3">3</a></sup> — fait référence à la mémoire CPU qui est directement visible depuis le GPU ; la lecture de cette mémoire passe par le bus PCI-express. En l’absence du type de mémoire précédent, cela devrait généralement être le choix pour les <em>uniform buffers</em> ou les <em>vertex/index buffers</em> dynamiques, et devrait également être utilisé pour stocker les <em>staging buffers</em> utilisés pour remplir les ressources statiques allouées avec <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>.</p>
</li>
<li>
<p><code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code> — fait référence à la mémoire GPU qui ne sera peut-être jamais allouée pour les cibles de rendu (sur les architectures en tuiles). Il est recommandé d’utiliser la mémoire allouée paresseusement (<em>lazily</em>) afin d’économiser la mémoire physique pour les grosses cibles de rendu qui n’y sont jamais stockées, telles que les images MSAA ou les images de profondeur. Sur les GPU intégrés, il n’y a aucune distinction entre le GPU et la mémoire du CPU — ces dispositifs exposent généralement <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> pour que vous puissiez également allouer toutes les ressources statiques.</p>
</li>
</ul>
<p>Dans le cas des ressources dynamiques, l’allocation dans la mémoire visible de l’hôte et ailleurs que sur le dispositif local, fonctionne en général bien — ça simplifie la gestion de l’application et est efficace grâce à la mise en cache des données en lecture seule côté GPU. Pour les ressources ayant un degré important d’accès aléatoires, comme les textures dynamiques, il est préférable de les allouer dans <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> et d’envoyer les données à l’aide de <em>staging buffers</em> alloués dans la mémoire <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> — comme vous le feriez pour des textures statiques. Vous pourriez être amené à le faire également pour les buffers — bien que les <em>uniform buffers</em> n’en souffrent généralement pas, certaines applications utilisant de larges buffers de stockage avec des modèles d’accès hautement aléatoire généreront trop de transactions PCI-express, à moins que vous ne copiiez d’abords les buffers sur le GPU ; de plus, la mémoire hôte a une latence d’accès plus élevée depuis le GPU pouvant impacter les performances pour de nombreux petits appels.</p>
<p>En cas de surabonnement de VRAM, vous pouvez manquer de mémoire lors de l’allocation des ressources depuis <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> ; dans ce cas, vous devriez revenir à l’allocation des ressources dans la mémoire non locale <code>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> du dispositif. Bien entendu, vous devez vous assurer que les ressources importantes fréquemment utilisées, telles que les cibles de rendu, sont allouées en premier. Il y a d’autres choses que vous pouvez faire en cas de surabonnement, comme la migration des ressources moins fréquemment utilisées de la mémoire GPU vers la mémoire CPU — cela sort du cadre de cet article ; de plus, sur certains systèmes d’exploitation, comme Windows 10, la gestion correcte du surabonnement nécessite d’APIs indisponibles dans Vulkan actuellement.</p>
<h3 id="sous-allocation-de-la-memoire">Sous-allocation de la mémoire</h3>
<p>Contrairement à d’autres API permettant d’effectuer une allocation mémoire par ressource, dans Vulkan ce n’est pas pratique pour les grosses applications — les pilotes sont supposés ne prendre en charge que jusqu’à 4096 allocations individuelles. À ce nombre limité s’ajoute le fait que les allocations peuvent être lentes à effectuer, peuvent gâcher de la mémoire en faisant l’hypothèse des pires conditions d’alignement possibles, et également nécessiter une surcharge supplémentaire pendant la soumission du <em>command buffer</em> pour s’assurer de la présence en mémoire de tout ce qui est nécessaire aux-dites commandes. La sous-allocation est nécessaire pour ces raisons. Une façon typique de travailler avec Vulkan consiste à effectuer des allocations volumineuses (e.g. de 16 Mo à 256 Mo dépendant de la dynamique des besoins en mémoire) à l’aide de <code>vkAllocateMemory</code>, puis d’effectuer des sous-allocations d’objets à l’intérieur de cette mémoire, ce qui revient à la gérer vous-même. Plus important encore, l’application doit gérer correctement l’alignement des demandes de mémoire, ainsi que la limite <code>bufferImageGranularity</code> qui restreint les configurations valides de buffers et d’images.</p>
<p>En bref, <code>bufferImageGranularity</code> restreint le placement relatif des ressources de buffer et d’images au sein d’une même allocation, ce qui nécessite un remplissage supplémentaire entre chaque allocation. Il existe plusieurs façons de régler cela :</p>
<ul>
<li>Alignez systématiquement les ressources d’images (car elles commencent généralement par un alignment plus grand) sur <code>bufferImageGranularity</code>, en utilisant essentiellement le maximum de l’alignement requis et <code>bufferImageGranularity</code> pour l’adresse et la taille de l’alignement.</li>
<li>Suivez le type de ressource pour chaque allocation et demandez à l’allocateur d’ajouter le rembourrage d’alignement requis seulement si la ressource précédente ou suivante est d’un type différent. Cela nécessite un algorithme d’allocation un peu plus complexe.</li>
<li>Allouez les images et les buffers dans des allocations Vulkan séparées pour supprimer totalement le problème. Cela réduit la fragmentation interne due aux petits rembourrages d’alignements, mais peut gaspiller plus de mémoire si la taille des allocations principales sont trop importantes (e.g. 256 Mo).</li>
</ul>
<p>Sur de nombreux GPU, l’alignement requis par les ressources d’images est nettement plus important que pour les buffers, ce qui rend la dernière option intéressante — en plus de réduire le gaspillage de mémoire grâce à l’absence de remplissage entre les buffers et les images, il réduit la fragmentation interne causée par l’alignement de l’image lorsque cette dernière suit un buffer de ressource. VMA fournit des implémentations pour l’option 2 (par défaut) et 3 (voir <code>VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT</code>).</p>
<h3 id="allocations-dediees">Allocations dédiées</h3>
<p>Bien que le modèle de gestion de la mémoire de Vulkan implique que l’application effectue des larges allocations et place plusieurs ressources dans chacune d’elle en utilisant les sous-allocation, sur certains GPU il est plus efficace d’allouer certaines ressources sous la forme d’une allocation dédiée. Dans certaines circonstances spéciales, le pilote peut allouer les ressources dans une mémoire plus rapide.</p>
<p>Pour cela, Vulkan fournit une extension (dans core en 1.1) permettant d’effectuer des allocations dédiées — lors de l’allocation de la mémoire, vous pouvez indiquer que vous allouez cette mémoire pour une ressource particulière plutôt que comme un blob opaque. Pour savoir si ça en vaut la peine, vous pouvez interroger les besoins de la mémoire étendue via <code>vkGetImageMemoryRequirements2KHR</code> ou <code>vkGetBufferMemoryRequirements2KHR</code> ; la structure résultante, <code>VkMemoryDedicatedRequirementsKHR</code>, contiendra les indicateurs <code>requiresDedicatedAllocation</code> (qui peut être défini si la ressource allouée nécessite d’être partagée avec d’autres processus) et <code>prefersDedicatedAllocation</code>.</p>
<p>En général, suivant le matériel et les pilotes, les performances des applications peuvent s’améliorer grâce aux allocations dédiées sur des cibles de rendu volumineuses nécessitant beaucoup de bande passante en lecture/écriture.</p>
<h3 id="mappage-de-la-memoire">Mappage de la mémoire</h3>
<p>Vulkan propose deux façons de mapper la mémoire pour obtenir un pointeur visible par le CPU :</p>
<ul>
<li>Mapper avant que le CPU n’ait besoin d’écrire des données sur l’allocation, en démapper une fois que l’écriture est terminée.</li>
<li>Mapper juste après l’allocation de la mémoire visible par l’hôte, et ne jamais démapper la mémoire.</li>
</ul>
<p>La seconde option, parfois appelé « mappage persistant », est généralement un meilleur compromis — elle minimise le temps nécessaire à l’obtention d’un pointeur inscriptible (<code>vkMapMemory</code> n’est pas particulièrement rapide sur certains pilotes), permet de ne pas gérer le cas où plusieurs ressources d’un même objet mémoire s’écrivent simultanément (l’appel à <code>vkMapMemory</code> sur une allocation qui a déjà été mappée, mais pas démappée est invalide) et simplifie le code en général.</p>
<p>Le seul inconvénient est que cette technique rend moins utile le bloc de 256 Mo de VRAM visible par l’hôte et le dispositif local sur les GPU AMD décrit dans « Sélection de la mémoire de tas » — sur les systèmes avec Windows 7 et un GPU AMD, utiliser un mappage persistant peut forcer WDDM à migrer les allocations vers la mémoire système. Si cette combinaison est celle de vos utilisateurs et que vous souhaitez les meilleures performances possibles, le mappage et le démappage de la mémoire aux besoins peut être plus adapté.</p>
<h2 id="sets-de-descripteurs">Sets de descripteurs</h2>
<p>Contrairement aux API précédentes utilisant un modèle de <em>binding</em> par emplacements, dans Vulkan, l’application à plus de liberté sur comment passer des ressources au shaders. Les ressources sont groupées dans des sets de descripteurs ayant un agencement spécifié par l’application, et chaque shader peut utiliser plusieurs sets de descripteurs pouvant être liés individuellement. Il est de la responsabilité de l’application de gérer les sets de descripteurs en s’assurant que le CPU ne met pas à jour un set de descripteurs utilisé par le GPU, et de fournir l’agencement ayant le meilleur équilibre possible entre le coût de mise à jour côté CPU et le coût d’accès côté GPU. De plus, comme les APIs de rendu utilisent des modèles de <em>binding</em> de ressources différents et qu’aucune ne correspond exactement au modèle utilisé par Vulkan, utiliser l’API de façon efficace et multi-plateforme devient compliqué. Nous allons voir plusieurs approches pour travailler avec les sets de descripteurs de Vulkan du point de vue de la facilité d’utilisation et des performances.</p>
<h3 id="modele-mental">Modèle mental</h3>
<p>Quand on utilise les sets de descripteurs, il est utile d’avoir un modèle mental sur la façon dont ils pourraient être mappés au matériel. Une des possibilités — et la conception attendue — est qu’ils mappent un bloc de la mémoire GPU contenant des descripteurs — des blobs opaques de données, de 16 à 64 octets suivant la ressource, définissant l’intégralité des paramètres des ressources nécessaires à l’accès aux données des ressources par le shader. Lors de la distribution du travail aux shaders, le CPU peut spécifier un nombre limité de pointeurs vers des sets de descripteurs ; ces pointeurs deviennent disponibles aux shaders quand les threads de shader se lancent.</p>
<p>Dans l’esprit, l’API Vulkan se map plus ou moins directement à ce modèle — créer une <em>pool</em> de set de descripteurs revient à allouer un bloc de mémoire GPU suffisamment large pour contenir le nombre maximum de descripteurs spécifié. Allouer un set de descripteurs à une <em>pool</em> peut être aussi simple qu’incrémenter le pointeur sur la <em>pool</em> par la taille cumulée des descripteurs alloués tel que déterminé par <code>VkDescriptorSetLayout</code> (notez qu’une telle implémentation ne pourrait pas supporter la réclamation de mémoire lors de la libération individuelle des descripteurs de la <em>pool</em> ; <code>vkResetDescriptorPool</code> ramènerai le pointeur au début de la mémoire de la <em>pool</em> et rendrait la <em>pool</em> entière à nouveau disponible à l’allocation). Enfin, <code>vkCmdBindDescriptorSets</code> émettrait des commandes de <em>command buffers</em> définissant les registres GPU correspondant aux pointeurs des sets de descripteurs.</p>
<p>Notez que ce modèle ignore beaucoup de complexités, tel que le décalage des buffers dynamiques, le nombre limité de ressources matérielles pour les sets de descripteurs, etc. De plus, il ne s’agit que d’une implémentation possible — certains GPU ont un modèle de descripteurs moins générique et imposent au pilote d’effectuer un traitement supplémentaire quand les sets de descripteurs sont liés au pipeline. Cela dit, c’est un modèle utile pour planifier l’allocation/l’utilisation des sets de descripteurs.</p>
<h3 id="gestion-des-sets-de-descripteurs-dynamiques">Gestion des sets de descripteurs dynamiques</h3>
<p>Aux vues du modèle mental ci-dessus, vous pouvez traiter les sets de descripteurs comme de la mémoire visible par le GPU — il est de la responsabilité de l’application de grouper les sets de descripteurs dans les <em>pools</em> et de les conserver jusqu’à ce que le GPU ait terminé de les lire.</p>
<p>Un schéma qui fonctionne bien consiste à utiliser des listes libres de <em>pools</em> de sets de descripteurs ; dès que vous avez besoin d’une <em>pool</em> de sets de descripteurs, vous en allouez une depuis la liste libre et l’utilisez pour les allocations de sets de descripteurs ultérieures pour la frame courante du thread courant. Quand vous n’avez plus de sets de descripteurs dans la <em>pool</em> courante, vous allouez une nouvelle <em>pool</em>. Toute les <em>pools</em> utilisées sur une frame donnée doivent être conservées ; une fois le rendu de la frame terminée, tel que déterminé par les objets <em>fence</em>, les <em>pools</em> de sets de descripteurs peuvent être réinitialisés via <code>vkResetDescriptorPool</code> et renvoyés dans des listes libres. Bien qu’il soit possible de libérer des descripteurs individuels d’une <em>pool</em> via <code>VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT</code>, cela complique la gestion de la mémoire côté pilote et n’est pas recommandé.</p>
<p>Quand une <em>pool</em> de sets de descripteurs est créée, l’application spécifie le nombre maximum de sets de descriptors qu’elle alloue, ainsi que le nombre maximum de descripteurs de chaque type qu’elle peut allouer. Dans Vulkan 1.1, l’application n’a pas prendre ces limites en compte — elle peut simplement appeler <code>vkAllocateDescriptorSets</code> et gérer l’erreur de cet appel en passant sur une nouvelle <em>pool</em> de sets de descripteurs. Malheureusement, appeler <code>vkAllocateDescriptorSets</code> dans Vulkan 1.0 sans aucune extension, entraîne une erreur si la <em>pool</em> n’a pas d’espace disponible, donc l’application doit suivre le nombre de sets et de descripteurs de chaque type pour anticiper quand elle doit basculer vers une <em>pool</em> différente.</p>
<p>Différents objets de pipeline peuvent utiliser différents nombres de descripteurs, ce qui pose la question de la configuration de la <em>pool</em>. Une approche simple consiste à créer toutes les <em>pools</em> avec la même configuration qui utilise le pire nombre de descripteurs possible pour chaque type — par exemple, si chaque set peut utiliser au plus 16 descripteurs de textures et 8 descriptors de buffers, nous pouvons allouer toutes les <em>pools</em> avec maxSets=1024, une taille de <em>pool</em> de 16 × 1024 pour les descripteurs de textures et 8 × 1024 pour les descriptors de buffers. Cette approche peut fonctionner, mais en pratique elle peut entraîner un gaspillage très important de la mémoire pour les shaders avec un nombre de descripteurs différent — vous ne pouvez pas allouer plus de 1024 sets de descripteurs à partir d’une <em>pool</em> ayant la configuration susmentionnée, donc si la plupart de vos objets de pipeline utilisent 4 textures, vous gaspillerez 75 % de la mémoire du descripteur de texture.</p>
<p>Deux alternatives qui offrant un meilleur équilibre avec l’utilisation de la mémoire sont :</p>
<ul>
<li>Mesurez un nombre moyen de descripteurs utilisés dans un pipeline de shaders par type pour une scène caractéristique et allouez les tailles des <em>pools</em> en conséquence. Par exemple, si, pour une scène donnée, nous avons besoin de 3000 sets de descripteurs, 13 400 descripteurs de textures, et 1700 descripteurs de buffers, alors le nombre moyen de descripteurs par set sera de 4,47 pour les textures (arrondi à 5) et 0,57 pour les buffers (arrondi à 1), donc la configuration raisonnable d’une <em>pool</em> est maxSets=1024, 5 × 1024 descripteurs de textures et 1024 descripteurs de buffers. Quand une <em>pool</em> est à court de descripteurs d’un type donné, nous en allouerons un nouveau — donc ce schéma a la garantie de fonctionner et devrait être raisonnablement efficace en moyenne.</li>
<li>Regroupez les objets du pipeline de shader classes de taille, suivant les utilisations générales approximatives des descripteurs, et choisissez les <em>pools</em> de sets de descripteurs en utilisant la classe de taille appropriée. C’est une extension du schéma décrit ci-dessus avec plus d’une classe de taille. Par exemple, il est fréquent d’avoir un grand nombre de <em>draw calls</em> pour les pré-passes d’ombre/de profondeur et un grand nombre de <em>draw calls</em> normaux dans une scène — mais ces deux groupes ont un nombre de descripteurs requis différents, avec les <em>draw calls</em> des ombres nécessitant 0 à 1 textures par set et 0 à 1 buffer quand les buffers dynamiques sont utilisées. Pour optimiser l’utilisation de la mémoire, il est plus approprié d’allouer des <em>pools</em> de sets de descripteurs séparées pour l’ombre/la profondeur et les autres <em>draw calls</em>. De la même manière que les allocateurs à usage général peuvent avoir des classes de taille optimales pour une application donnée, une gestion des sets de descripteurs plus bas niveau est toujours possible, tant qu’il est préalablement configuré avec les usages de sets de descripteurs spécifiques à l’application.</li>
</ul>
<h3 id="choisir-le-bon-type-de-descripteurs">Choisir le bon type de descripteurs</h3>
<p>Vulkan propose plusieurs façons d’accéder à chaque type de ressource dans un shader ; c’est à l’application de choisir le type de descripteur optimal.</p>
<p>Pour les buffers, l’application doit choisir entre les <em>uniform buffers</em> et les <em>storage buffers</em>, et d’utiliser ou non les décalages dynamiques. Les <em>uniform buffers</em> ont un limite de taille maximale adressable — sur du matériel de bureau, vous avez jusqu’à 64 Ko de données, mais certains GPU mobiles ne fournissent que 16 Ko de données (ce qui est également le minimum garanti par la spécification). Le buffer de ressource peut être plus grand, mais un shader ne peut accéder qu’à cette quantité de données pour un descripteur.</p>
<p>Sur certains matériels, il n’y a aucune différence en vitesse d’accès entre les <em>uniform buffers</em> et les <em>storage buffers</em>, mais pour d’autres, suivant le modèle d’accès, les <em>uniform buffers</em> peuvent être beaucoup plus rapides. Préférez les <em>uniform buffers</em> pour les données de petite et moyenne taille, en particulier si la façon d’y accéder est fixe (e.g. pour un buffer avec des constantes de matériaux ou de scènes). Les <em>storage buffers</em> sont plus adaptés quand vous avez besoin de tableaux de données plus grand que la limite de taille des <em>uniform buffers</em> et sont indexés dynamiquement dans le shader.</p>
<p>Pour les textures, si le filtrage est requis, vous avez le choix entre :</p>
<ul>
<li>Avoir des descripteurs combinés image/sampler (où, tout comme OpenGL, le descripteur définit à la fois la source des données de la texture, et les propriétés de filtrage/d’adressage)</li>
<li>Séparer les descripteurs d’images et de samplers (ce qui correspond mieux au modèle de Direct3D 11)</li>
<li>Avoir un descripteur d’image avec un descripteur de sampler immuable, dont les propriétés doivent être spécifiées au moment de la création du pipeline.</li>
</ul>
<p>Les performances relatives de ces méthodes dépendent grandement de la façon dont elles sont utilisées ; cela dit, en général, les descripteurs immuables correspondent mieux à l’usage recommandé par les nouvelles APIs, comme Direct3D 12, et donnent au pilote plus de liberté pour optimiser le shader. Cela modifie dans une certaine mesure la conception du moteur de rendu, l’obligeant à implémenter l’aspect dynamique de certaines parties de l’état du sampler, tel que le <em>LOD bias</em> par texture, pour les transitions de texture streamées, en utilisant les instructions ALU du shader.</p>
<h3 id="binding-par-emplacement">Binding par emplacement</h3>
<p>Une alternative basique au mécanisme de binding de Vulkan est le celui de Metal/Direct3D 11 dans lequel une application peut lier des ressources à des emplacements, et le moteur d’exécution/pilote gère la mémoire du descripteur et les paramètres du set de descripteurs. Cette approche peut être implémentée via les sets de descripteurs Vulkan ; bien qu’il ne fournisse pas les résultats les plus optimaux, il s’agit d’un bon modèle par lequel commencer lors du portage d’un moteur de rendu existant, et il peut se révéler étonnamment efficace s’il est correctement implémenté.</p>
<p>Pour que ce modèle fonctionne, l’application doit définir un nombre de blocs de ressources présent et comment ils se mappent aux indices de set/emplacements Vulkan. Par exemple, en Metal, chaque étape (VS, FS, CS) a trois blocs de ressources — textures, buffers et samplers — sans différenciations entre, par exemple, les <em>uniform buffers</em> et les <em>storage buffers</em>. En Direct3D 11, les blocs sont plus compliqués, car les buffers en lecture-seule appartiennent au même bloc que celui des textures, mais les textures et les buffers utilisant des accès non-ordonnés résident appartiennent à un autre.</p>
<p>Les spécifications de Vulkan ne garantissent qu’un minimum de 4 sets de descripteurs accessible à l’ensemble du pipeline (à travers toutes les étapes) ; pour cette raison, le mappage le plus pratique consiste à avoir le même binding de ressource pour toutes les étapes — par exemple, l’emplacement de texture 3 pourrait contenir la même ressource de texture quelle que soit l’étape à partir de laquelle on y accède — et utiliser différents sets de descripteurs pour chaque type, e.g. le set 0 pour les buffers, le set 1 pour les textures, le set 2 pour les samplers. L’application peut aussi utiliser un seul set de descripteurs par étape<sup id="fnref:4"><a class="footnote-ref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fn:4">4</a></sup> et effectuer un remappage d’index statique (e.g. les emplacements 0 à 16 pourrait être utilisés pour les textures, ceux de 17 à 24 pour les <em>uniform buffers</em>, etc.) — ce qui, en revanche, n’est pas recommandé, car on risque d’utiliser beaucoup plus de mémoire de set de descripteurs. Enfin, on pourrait implémenter une table de remappage dynamique, précise et compact, d’emplacements pour chaque étape de shader (e.g. si un <em>vertex shader</em> utilise les emplacements de texture 0, 4, 5, ils sont mappés aux indices de descripteur 0, 1, 2 du set 0, et au moment de l’exécution, l’application extrait les informations de texture voulues depuis cette table de remappage).</p>
<p>Dans tous ces cas, l’implémentation d’une définition de texture à un emplacement donné n’exécuterait, en général, aucune commande Vulkan et ne ferait que mettre à jour les états dans l’ombre ; juste avant le <em>draw call</em> ou la distribution des commandes, vous devez allouer un set de descripteurs à partir de la <em>pool</em> voulu, le mettre à jour avec les nouveaux descripteurs, et binder tous les sets de descripteurs via la commande <code>vkCmdBindDescriptorSets</code>. Notez que si un set de descripteurs a 5 ressources, et que seul une d’entre elle a changé depuis le dernier <em>draw call</em>, vous devez quand même allouer un nouveau set de descripteurs avec 5 ressources et toutes les mettre à jour.</p>
<p>Pour obtenir de bonnes performances avec cette approche, vous devez suivre plusieurs directives :</p>
<ul>
<li>N’allouez ni ne mettez à jour aucun set de descripteurs quand rien n’a changé dans ce dernier. Dans le modèle où les emplacements sont partagés entre les différentes étapes, cela peut vouloir dire que si aucune texture n’est défini entre deux <em>draw calls</em>, vous n’avez pas besoin d’allouer ou de mettre à jour le set de descripteurs avec des descripteurs de textures.</li>
<li>Appelez <code>vkAllocateDescriptorSets</code> par lot quand cela est possible — sur certains pilotes, chaque appel entraîne une surcharge importante, donc si vous devez mettre à jour plusieurs sets, les allouer en un seul appel peut être plus rapide.</li>
<li>Pour mettre à jour les sets de descripteurs, utilisez soit <code>vkUpdateDescriptorSets</code> avec un tableau de <code>VkWriteDescriptorSet</code>, ou utilisez <code>vkUpdateDescriptorSetWithTemplate</code> de Vulkan 1.1. Utilisez la fonctionnalité de copy de descripteurs de <code>vkUpdateDescriptorSets</code> est tentant dans le cas d’une gestion dynamique des descripteurs pour copier la plupart des descripteurs d’un tableau précédemment alloué, mais cela peut être lent sur les pilotes qui allouent les descripteurs depuis de la mémoire en écriture combinée. Les templates de descripteur peuvent réduire la quantité de travail que l’application doit effectuer pour faire les mises à jour — dans la mesure où, avec cette approche, il vous faut lire les informations de descripteurs depuis leur état dans l’ombre maintenu par l’application, les templates de descripteur vous permettent d’indiquer au pilote l’agencement de votre état dans l’ombre, rendant les mises à jours beaucoup plus rapides sur certains pilotes.</li>
<li>Enfin, préférez les <em>uniform buffers</em> dynamiques pour mettre à jour les descripteurs d’<em>uniform buffers</em>. Les <em>uniform buffers</em> dynamiques permettent de spécifier des décalages dans les objets de buffers en utilisant l’argument <code>pDynamicOffsets</code> de <code>vkCmdBindDescriptorSets</code> sans allouer ni mettre à jour de nouveaux descripteurs. Cela fonctionne bien avec la gestion dynamique des constantes où les constantes des <em>draw calls</em> sont allouées depuis de larges <em>uniform buffers</em>, ça réduit la surcharge CPU de façon significative, et peut être plus efficace sur le GPU. Bien que sur certains GPU, le nombre de buffer dynamiques doivent être gardés petit pour éviter une surcharge supplémentaire dans le pilote, cette approche devraient bien fonctionner avec un ou deux <em>uniform buffers</em> dynamiques sur toutes les architectures.</li>
</ul>
<p>En général, l’approche décrite ci-dessus peut être très efficace en termes de performances. Elle n’est pas aussi efficace que les approches avec des sets de descripteurs plus statiques décrits ci-dessous, mais si elle est implémentée avec soin elle a le mérite de s’accommoder aux API plus anciennes. Sur certains pilotes, malheureusement, l’approche allocation et mise à jour n’est pas optimal — sur certains matériels mobiles, il peut être judicieux de mettre en cache les sets de descripteurs en fonction des descripteurs qu’ils contiennent s’ils peuvent être réutilisés plus tard dans la frame.</p>
<h3 id="sets-de-descripteurs-par-frequence">Sets de descripteurs par fréquence</h3>
<p>Bien que le binding de ressources par emplacement soit une approche simple et familière, elle ne se traduit pas par des performances optimales. Certains matériels mobiles ne peuvent pas prendre en charge plusieurs sets de descripteurs ; cependant, en général, l’API Vulkan et le pilote attendent d’une l’application qu’elle gère les sets de descripteurs en fonction de la fréquence des changements.</p>
<p>Un moteur de rendu focalisé sur Vulkan grouperait les données dont les shaders ont besoins suivant leur fréquence de changements, et utiliserait des sets particuliers pour des fréquences particulières, avec set=0 pour les changements les moins fréquents, et set=3 pour les changements les plus fréquents. À titre d’exemple, une configuration typique impliquerait :</p>
<ul>
<li>Un set de descripteurs set=0 contenant un <em>uniform buffer</em> avec des données globales par frame, par vue, ainsi que des textures globales comme le tableau/l’atlas de <em>shadow map</em>.</li>
<li>Un set de descripteurs set=1 contenant un <em>uniform buffer</em> et des descripteurs de texture pour les données par matériaux, comme la map d’albédo, les coefficients de Fresnel, etc.</li>
<li>Un set de descripteurs set=2 contenant un <em>uniform buffer</em> dynamique avec des données par appel, tel que le tableau des transformations monde.</li>
</ul>
<p>Le but est que set=0 ne change qu’une poignée de fois par image ; on peut utiliser un modèle d’allocation dynamique tel que décrit dans la section précédente.</p>
<p>Pour set=1, le but est que pour la plupart des objets, les données de matériaux ne change pas entre les frames, et donc puissent être allouées et mis à jour que lorsque le code du jeu ne change ces données.</p>
<p>Enfin, les données de set=2 seraient complètement dynamiques — du fait de l’utilisation d’un <em>uniform buffer</em> dynamique, nous aurions rarement à allouer et mettre à jour ce set de descripteurs — en supposant que les constantes dynamiques soient envoyées dans une série de gros buffers par image, pour la plupart des <em>draw calls</em> nous mettrions à jour le buffer avec les constantes, puis appellerions <code>vkCmdBindDescriptorSets</code> avec de nouveaux décalages.</p>
<p>Notez qu’en raison des règles de compatibilité entre les objets de pipeline, il suffit la plupart du temps de binder les sets 1 et 2 dès qu’un matériel change, et seulement le set 2 quand les matériaux sont les mêmes que ceux du <em>draw calls</em> précédent. Ce qui a pour effet d’appeler <code>vkCmdBindDescriptorSets</code> qu’une seule fois par <em>draw call</em>.</p>
<p>Dans un moteur de rendu complexe, chaque shaders peut avoir à utiliser un agencement différent — en effet, tous les shaders n’ont pas besoins de s’accorder sur le même agencement des données de matériaux. Dans de rares cas, il peut être judicieux d’utiliser plus de 3 sets en fonction de la structure de la frame. De plus, étant donné la flexibilité de Vulkan, il n’est pas obligatoire d’utiliser le même système de binding de ressources pour tous les <em>draw calls</em> d’une scène. Par exemple, les chaînes de <em>draw calls</em> post-traitement ont tendance à être hautement dynamiques, avec des textures/constantes changeant entièrement entre chaque <em>draw call</em>. Certains moteurs de rendu implémentèrent d’abord le modèle de binding par emplacement dynamique de la section précédente, puis ajoutèrent l’approche par fréquence pour le rendu du monde afin de minimiser la pénalité de performance de la gestion des sets, tout en gardant la simplicité du modèle par emplacement pour les parties dynamiques du pipeline de rendu.</p>
<p>Le modèle décrit ci-dessus suppose que dans la plupart des cas, la taille des données par rendu est plus importante que si elles étaient envoyées en poussant des constantes. Pousser des constantes peut se faire sans mettre à jour ou rebinder les sets de descripteurs ; avec la garantie d’avoir une taille maximale de 128 octets par <em>draw call</em>, il est tentant de les utiliser pour des données par rendu comme la matrice de transformation 4 × 3 d’un objet. Cependant, sur certaines architectures, le nombre réel de constantes qu’il est possible de pousser rapidement, dépend de la configuration du descripteur que les shaders utilisent, et est au alentours de 12 bytes. Dépasser cette limite peut forcer le pilote à stocker les constantes à pousser dans un <em>ring buffer</em> qu’il gère, ce qui peut se révéler plus coûteux que de déplacer ces données dans une <em>uniform buffer</em> dynamique depuis l’application. Bien que pour certaines conceptions, pousser les constantes de façon limitée puisse être une bonne idée, il est plus judicieux de le faire via un modèle entièrement <em>bindless</em>, tel que décrit dans la section suivante.</p>
<h3 id="conceptions-de-descripteurs-bindless">Conceptions de descripteurs <em>bindless</em></h3>
<p>Les sets de descripteurs par fréquence réduisent la surcharge du binding des sets de descripteurs ; cela dit, il vous reste toujours un ou deux sets de descripteurs par <em>draw calls</em> à binder. Maintenir des sets de descripteurs de matériaux nécessite une couche de gestion visant à mettre à jour les sets de descripteurs du GPU dès que des paramètres de matériaux change ; de plus, comme les descripteurs de textures sont cachés dans les données des matériaux, cela rend les systèmes de streaming de textures globaux difficiles à gérer — dès que des niveaux de mipmap d’une texture sont envoyés ou retiré, tous les matériaux utilisant cette texture doivent être mis à jour. Cela nécessite une interaction complexe entre le système des matériaux et celui de streaming de texture et introduit une surcharge supplémentaire dès qu’une texture est ajustée — ce qui amoindri les avantages de l’approche par fréquence. Enfin, le besoin de configurer des sets de descripteurs par <em>draw call</em> fait qu’il est difficile d’adapter les méthodes susmentionnées à du <em>culling</em> ou à la soumission de commandes côté GPU.</p>
<p>Il est possible de concevoir une approche <em>bindless</em> où le nombre d’appels requis pour définir les binding est constant pour le rendu du monde, qui dissocie les descripteurs de texture de ceux des matériaux, rendant les systèmes de streaming de textures plus simple à implémenter, et facilite la soumission côté GPU. Tout comme l’approche précédente, elle peut être combinée avec des mises à jours de descripteurs ad-hoc dynamique pour les parties de la scène où le nombre de <em>draw calls</em> est faible, et où la flexibilité est importante, comme le post-traitement.</p>
<p>Pour tirer pleinement parti du <em>bindless</em>, Vulkan core risque de ne pas être suffisant ; certaines implémentations du blindless nécessitent la mise à jour des sets de descripteurs sans les rebinder après cette dernière, chose indisponible en Vulkan 1.0 et 1.1, mais faisable via l’extension <code>VK_EXT_descriptor_indexing</code> (dans core en 1.2). Cela dit, la conception de base décrite ci-dessous fonctionne sans extensions, du fait d’une limite de sets de descripteurs suffisamment élevés. Ceci nécessite la mise en place d’un <em>double buffer</em> du tableau des descripteurs de texture décrit ci-dessous pour mettre à jour les descripteurs, car le tableau sera constamment lu par le GPU.</p>
<p>Comme pour l’approche par fréquence, nous diviserons les données de shader en uniformes et textures globaux (set 0), données de matériaux et données par rendu. Les uniformes et textures globaux peuvent être spécifiés via un set de descripteurs tel que décrit dans la section précédente.</p>
<p>Pour les données par matériau, nous déplacerons les descripteurs de texture dans un grand tableau de descripteurs de textures (note : il s’agit d’un concept différent du tableau de textures — un tableau de texture utilise un seul descripteur et force toutes les textures à avoir la même taille et le même format ; un tableau de descripteurs n’a pas cette limitation et chacun de ces éléments peut être un descripteur de textures arbitraire, voir un tableau de descripteurs de textures), Chaque matériau des données de matériaux aura un index dans ce tableau au lieu de son descripteur de texture ; l’index fera partie des données de matériaux, qui auront également d’autres constantes de matériaux.</p>
<p>Chaque constante de chaque matériau de la scène sera stocké dans un gros <em>storage buffer</em> ; bien que cette approche permette de prendre en charge plusieurs types de matériaux, nous partirons du principe que chaque matériau puisse être défini via les mêmes données, par souci de simplicité. Exemple de structure de données de matériau ci-dessous :</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">MaterialData</span>
<span class="p">{</span>
    <span class="n">vec4</span> <span class="n">albedoTint</span><span class="p">;</span>

    <span class="kt">float</span> <span class="n">tilingX</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">tilingY</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">reflectance</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">unused0</span><span class="p">;</span> <span class="c1">// pad to vec4</span>

    <span class="n">uint</span> <span class="n">albedoTexture</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">normalTexture</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">roughnessTexture</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">unused1</span><span class="p">;</span> <span class="c1">// pad to vec4</span>
<span class="p">};</span>
</pre></div>


<p>De la même façon, toutes les constantes par rendu de tous les objets de la scène peuvent être stockées dans un autre gros <em>storage buffer</em> ; par souci de simplicité, nous partirons du principe que toutes les constantes par rendu ont une structure identique. Pour prendre en charge les objets skinnés avec une telle approche, nous allons extraire les données de transformation dans un troisième <em>storage buffer</em> distinct :</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">TransformData</span>
<span class="p">{</span>
    <span class="n">vec4</span> <span class="n">transform</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>


<p>Quelque chose que nous avons ignoré jusqu’à présent est la spécification des données de sommets. Bien que Vulkan fournisse un moyen direct de spécifier les données de sommets via l’appel <code>vkCmdBindVertexBuffers</code>, le fait de binder les <em>vertex buffers</em> par rendu ne fonctionnerait pas dans une conception <em>bindless</em>. De plus, certains matériels ne prennent pas directement en charge les <em>vertex buffers</em>, et le pilote doit émuler le binding des <em>vertex buffers</em>, ce que peut entraîner des ralentissements côté CPU quand on utilise <code>vkCmdBindVertexBuffers</code>. Une conception totalement <em>bindless</em> implique que tous les <em>vertex buffers</em> sont sous-alloués dans un gros buffer puis d’utiliser soit des décalages par rendu (l’argument <code>vertexOffset</code> de <code>vkCmdDrawIndexed</code>) pour que le matériel y récupère les données, soit de transmettre un décalage de buffer dans le shader à chaque <em>draw call</em> et de récupérer les données du buffer dans le shader. Les deux approches peuvent bien fonctionner et peuvent être plus ou moins efficaces suivant le GPU ; ici, nous partirons du principe que le <em>vertex shader</em> effectuera une récupération manuelle des sommets.</p>
<p>Ainsi, nous devons spécifier trois <em>integers</em> au shader pour chaque <em>draw call</em> :</p>
<ul>
<li>Index des matériaux ; utilisé pour lire les données des matériaux depuis le <em>storage buffer</em> des matériaux. Les textures sont ensuite accessibles à l’aide des indices des données de matériaux et du tableau de descripteurs.</li>
<li>Index des données de transformation ; utilisé pour lire les données de transformation dans le <em>storage buffer</em> des transformations.</li>
<li>Décalage des données de sommet ; utilisé pour lire les attributs de sommet dans le <em>storage buffer</em> des sommets.</li>
</ul>
<p>Si nécessaire, nous pouvons spécifier ces index et des données supplémentaires via cette structure :</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">DrawData</span>
<span class="p">{</span>
    <span class="n">uint</span> <span class="n">materialIndex</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">transformOffset</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">vertexOffset</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">unused0</span><span class="p">;</span> <span class="c1">// vec4 padding</span>

    <span class="c1">// ... extra gameplay data goes here</span>
<span class="p">};</span>
</pre></div>


<p>Le shader devra accéder aux <em>storage buffers</em> contenant <code>MaterialData</code>, <code>TransformData</code>, <code>DrawData</code> ainsi qu’à un <em>storage buffer</em> contenant les données des sommets. Ces buffers peuvent être bindés au shader grâce au set de descripteurs global ; la dernière information est l’index des données de rendu, qui peut être transmis en poussant une constante.</p>
<p>Avec cette approche, nous devons mettre à jour les <em>storage buffers</em> utilisés par les matériaux et les <em>draw calls</em> à chaque frame et les binder utilisant notre set de descripteurs global ; De plus, nous devons binder les données d’index — en supposant que, comme les données de sommet, les données d’index sont allouées dans un gros <em>index buffer</em>, nous n’avons besoin de les binder qu’une seule fois à l’aide de <code>vkCmdBindIndexBuffer</code>. Une fois la configuration globale terminée, pour chaque <em>draw call</em>, nous devons appeler <code>vkCmdBindPipeline</code> si le shader change, suivi de <code>vkCmdPushConstants</code> pour spécifier un index dans le <em>draw data buffer</em><sup id="fnref:5"><a class="footnote-ref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fn:5">5</a></sup>, suivi de <code>vkCmdDrawIndexed</code>.</p>
<p>Dans une conception centrée sure le GPU, au lieu de pousser les constantes par rendu, nous pouvons utiliser <code>vkCmdDrawIndirect</code> ou <code>vkCmdDrawIndirectCountKHR</code> (fourni par l’extension <code>KHR_draw_indirect_count</code>, dans core en 1.2) et les récupérer sous forme d’index en utilisant <code>gl_DrawIDARB</code> (fourni par l’extension <code>KHR_shader_draw_parameters</code>). La seule chose à garder à l’esprit est que pour la soumission basée sur le GPU, nous devrons regrouper les <em>draw calls</em> par <em>pipeline object</em> côté CPU, car il n’est pas possible de changer de <em>pipeline object</em> autrement.</p>
<p>Avec tout ça, le code de transformation des sommets du <em>vertex shader</em> pourrait ressembler à ça :</p>
<div class="highlight"><pre><span></span><span class="n">DrawData</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">drawData</span><span class="p">[</span><span class="n">gl_DrawIDARB</span><span class="p">];</span>
<span class="n">TransformData</span> <span class="n">td</span> <span class="o">=</span> <span class="n">transformData</span><span class="p">[</span><span class="n">dd</span><span class="p">.</span><span class="n">transformOffset</span><span class="p">];</span>
<span class="n">vec4</span> <span class="n">positionLocal</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">positionData</span><span class="p">[</span><span class="n">gl_VertexIndex</span> <span class="o">+</span> <span class="n">dd</span><span class="p">.</span><span class="n">vertexOffset</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">);</span>
<span class="n">vec3</span> <span class="n">positionWorld</span> <span class="o">=</span> <span class="n">mat4x3</span><span class="p">(</span><span class="n">td</span><span class="p">.</span><span class="n">transform</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">td</span><span class="p">.</span><span class="n">transform</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">td</span><span class="p">.</span><span class="n">transform</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">positionLocal</span><span class="p">;</span>
</pre></div>


<p>Le code de sampling des textures des matériaux du <em>fragment shader</em> pourrait ressembler à ça :</p>
<div class="highlight"><pre><span></span><span class="n">DrawData</span> <span class="n">dd</span> <span class="o">=</span> <span class="n">drawData</span><span class="p">[</span><span class="n">drawId</span><span class="p">];</span>
<span class="n">MaterialData</span> <span class="n">md</span> <span class="o">=</span> <span class="n">materialData</span><span class="p">[</span><span class="n">dd</span><span class="p">.</span><span class="n">materialIndex</span><span class="p">];</span>
<span class="n">vec4</span> <span class="n">albedo</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">sampler2D</span><span class="p">(</span><span class="n">materialTextures</span><span class="p">[</span><span class="n">md</span><span class="p">.</span><span class="n">albedoTexture</span><span class="p">],</span> <span class="n">albedoSampler</span><span class="p">),</span> <span class="n">uv</span> <span class="o">*</span> <span class="n">vec2</span><span class="p">(</span><span class="n">md</span><span class="p">.</span><span class="n">tilingX</span><span class="p">,</span> <span class="n">md</span><span class="p">.</span><span class="n">tilingY</span><span class="p">));</span>
</pre></div>


<p>Cette approche diminue la charge CPU, mais bien entendu, c’est avant tout un équilibre entre de plusieurs facteurs :</p>
<ul>
<li>Bien que l’approche puisse être étendue à plusieurs formats de données de matériaux, rendu et sommets, elle devient plus difficile à gérer.</li>
<li>Sur certaines architectures, utiliser exclusivement des <em>storage buffers</em> au lieu d’<em>uniform buffers</em> peut augmenter la charge GPU.</li>
<li>Récupérer les descripteurs de texture depuis un tableau indexé par données de matériaux, lui-même indexé par index de matériaux peut ajouter une indirection supplémentaire côté GPU, comparé à d’autres approches.</li>
<li>Sur certain GPU, les limites des sets de descripteurs peuvent rendre cette technique difficile à implémenter ; La valeur de <code>maxPerStageDescriptorSampledImages</code> doit être suffisamment importante pour accueillir l’intégralité des textures des matériaux de sorte qu’il soit ensuite possible d’indexer une texture arbitraire dynamiquement, depuis le shader — bien que de nombreux pilotes de bureau exposent une limite élevée, la spécification ne garantit qu’une limite de 16, donc le <em>bindless</em> reste hors de portée de certains matériels, bien que ces derniers supportent Vulkan.</li>
</ul>
<p>Plus le moteur de rendu se complexifie, plus l’approche <em>bindless</em> s’y généralise, permettant de déléguer au GPU des parts de plus en plus importantes du pipeline de rendu ; du fait des contraintes matériels, cette approche est inapplicable sur certains dispositif pourtant compatible Vulkan, mais ça vaut vraiment la peine de s’y attarder lors de la conception de nouvelles façon de rendre sur du futur matériel.</p>
<h2 id="enregistrement-et-soumission-de-command-buffers">Enregistrement et soumission de <em>command buffers</em></h2>
<p>Les anciennes API ont une chronologie unique pour les commandes GPU ; Les commandes exécutées sur le CPU sont exécutées dans le même ordre sur le GPU, car elles ne sont en général enregistrées que sur un seul thread ; il n’y a pas de contrôle précis sur le moment ou le CPU soumet les commandes au GPU, et le pilote est supposé gérer de façon optimale la mémoire utilisée par le flux de commandes ainsi que les moments de soumission.</p>
<p>En revanche, dans Vulkan, l’application est responsable de la gestion de la mémoire des <em>buffer commands</em>, de l’enregistrement des commandes en multi-thread dans plusieurs <em>buffer commands</em> et de leur soumission pour exécution au bon moment. Bien qu’un code méticuleusement écrit puisse rendre un moteur de rendu Vulkan mono-threadé beaucoup plus rapide qu’avec les API plus anciennes, l’efficacité maximale et la latence minimale sont obtenues en gérant l’enregistrement des commandes sur les nombreux cœurs du système, ce qui nécessite une gestion minutieuse de la mémoire.</p>
<h3 id="modele-mental_1">Modèle mental</h3>
<p>Tout comme les sets de descripteurs, les <em>command buffers</em> sont alloués dans des <em>pools</em> de commandes ; il est important de comprendre comment un pilote peut être amené à les implémenter pour pouvoir raisonner sur les coûts et les implications d’utilisation.</p>
<p>La <em>pool</em> de commandes doit gérer la mémoire qui sera remplie de commandes par le CPU et ensuite lue par le processeur de commandes du GPU. La quantité de mémoire utilisée par les commandes ne peut pas être déterminée statiquement ; l’implémentation typique d’une <em>pool</em> impliquerait donc une liste libre à taille de pages fixe. Le <em>command buffer</em> contiendrait une liste de pages avec les commandes qui nous intéressent, avec des commandes spéciales de saut qui transfèrent le contrôle de chaque page à la suivante afin que le GPU puisse toutes les exécuter séquentiellement. Chaque fois qu’une commande doit être allouée à partir d’un <em>command buffer</em>, elle sera encodée dans la page courante ; si la page actuelle n’a pas d’espace, le pilote allouera la page suivante à l’aide d’une liste libre de la <em>pool</em> associée, encodera un saut vers cette page dans la page actuelle et passera à la page suivante pour l’enregistrement des commandes ultérieures.</p>
<p>Chaque <em>pool</em> de commandes ne peut être utilisé que par un thread à la fois, les commandes ci-dessus n’ont donc pas besoin d’être thread-safe<sup id="fnref:6"><a class="footnote-ref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fn:6">6</a></sup>. Libérer le <em>command buffer</em> via <code>vkFreeCommandBuffers</code> peut renvoyer dans la <em>pool</em> les pages utilisées par le <em>command buffer</em> en les ajoutant à la liste libre. Réinitialiser la <em>pool</em> de commandes peut mettre toutes les pages utilisées par tous les <em>command buffers</em> de la liste libre de la <em>pool</em> ; lorsque <code>VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT</code> est utilisé, les pages peuvent être renvoyées au système afin que d’autres <em>pools</em> puissent les réutiliser.</p>
<p>Notez que rien ne garantit que <code>vkFreeCommandBuffers</code> renvoie réellement la mémoire à la <em>pool</em> ; certaines approches s’appuient sur plusieurs <em>command buffers</em> alloué en morceaux dans des pages plus grandes, ce qui compliquerait le recyclage de la mémoire de <code>vkFreeCommandBuffers</code>. En effet, pour un fabricant mobile en particulier, <code>vkResetCommandPool</code> est obligatoire pour réutiliser la mémoire pour un futur enregistrement de commande dans une configuration de base, lorsque les <em>pools</em> sont alloués sans <code>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</code>.</p>
<h3 id="enregistrement-des-commandes-multi-threade">Enregistrement des commandes multi-threadé</h3>
<p>Dans Vulkan, les deux restrictions fondamentales concernant l’utilisation des <em>pools</em> de commandes sont :</p>
<ul>
<li>Les <em>command buffers</em> alloués pour une <em>pool</em> ne peuvent pas être enregistrés par plusieurs threads simultanément.</li>
<li>Les <em>command buffers</em> et les <em>pools</em> ne peuvent pas être libérés ou réinitialisés tant que le GPU exécute les commandes associées.</li>
</ul>
<p>Pour ces raisons, une mise en place des threads nécessite un ensemble de <em>pools</em> de <em>command buffers</em>. Cet ensemble doit contenir F × T <em>pools</em>, où F correspond à la taille de la file d’attente des frames — F est généralement de 2 (une frame est enregistrée par le CPU pendant que l’autre est exécutée par le GPU) ou 3 ; T est le nombre de threads pouvant enregistrer des commandes en même temps, valeur qui peut atteindre le nombre de cœurs du système. Quand on enregistre des commandes depuis un thread, ce dernier doit allouer un <em>command buffer</em> depuis la <em>pool</em> qui lui est associée pour la frame donnée et y enregistrer les commandes. Si on part du principe que les <em>command buffers</em> ne sont pas remplies aux abords des frames, et qu’aux abords des frames la longueur de la file d’attente impose d’attendre que la dernière frame de la file d’attente soit exécutée, nous pouvons alors libérer tous les <em>command buffers</em> alloués à cette frame et réinitialiser toutes les <em>pools</em> des commandes associés.</p>
<p>De plus, plutôt que de libérer les <em>command buffers</em>, il est possible de les réutiliser après avoir appelé <code>vkResetCommandPool</code> — ce qui fait que les <em>command buffers</em> n’ont pas à être ré-alloués. Bien qu’en théorie l’allocation de <em>command buffers</em> soit rapide, elle peut se révéler coûteuse sur certains pilotes. Cela garantit également que le pilote n’a jamais besoin de redonner la mémoire des commandes au système, ce qui peut accélérer la soumission des commandes dans ces <em>buffers</em>.</p>
<p>Notez que suivant la structure de la frame, l’approche ci-dessus peut entraîner une consommation de mémoire déséquilibrée entre les threads ; par exemple, les <em>draw calls</em> des ombres nécessitent généralement une configuration et une utilisation de la mémoire des commandes moindre. Combiné à une distribution de la charge de travail aléatoire entre les threads, tel que produite par de nombreux <em>job schedulers</em>, vous pouvez vous retrouver avec des <em>pools</em> de commandes taillées pour le pire cas de consommation. Si une application est contrainte par la mémoire et que cela devient un problème, il est possible de limiter le gaspillage en limitant le parallélisme de chacune des passes puis de sélectionner la <em>commande buffer/pool</em> en fonction de la passe à enregistrer.</p>
<p>Cela nécessite l’introduction d’une organisation par taille au gestionnaire de <em>command buffer</em>. Avec un <em>pool</em> de commandes par thread et une réutilisation manuelle des <em>command buffers</em> alloués tel que suggéré ci-dessus, il est possible de maintenir une liste libre par groupe de taille, lesdits groupes étant définis suivant le nombre de <em>draw calls</em> (e.g. “&lt;100”, “100-400”, etc.) et/ou la complexité de chaque <em>draw call</em> (seulement du <em>depth</em>, <em>gbuffer</em>). Choisir les buffers en fonction de leur utilisation stabilise la consommation de la mémoire. De plus, pour les passes trop petites, il est intéressant de réduire le parallélisme de leur enregistrement — par exemple, si une passe a moins de 100 <em>draw calls</em> sur un système doté de 4&nbsp;cœurs, il peut être plus rapide de l’enregistrer sous un seul job plutôt que de la découper en 4 jobs, car cela permet de réduire la surcharge de la gestion de la mémoire des commandes et de soumission du <em>command buffer</em>.</p>
<h3 id="soumission-des-command-buffers">Soumission des <em>command buffers</em></h3>
<p>Bien qu’il soit plus efficace d’enregistrer des <em>command buffers</em> depuis plusieurs threads, le fait que les états ne soient pas partagés/réutilisés entre les <em>command buffers</em><sup id="fnref:7"><a class="footnote-ref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fn:7">7</a></sup> et les limitations du <em>schedulers</em> fait que les <em>command buffers</em> doivent être suffisamment gros pour s’assurer que le GPU n’est pas inactif pendant le traitement des commandes. De plus, chaque soumission entraîne une surcharge à la fois côté CPU et GPU. D’une façon générale, une application Vulkan devrait viser moins de 10 soumissions par frame (chaque soumission coûtant 0.5 ms de charge GPU, voir plus), et moins de 100 <em>command buffers</em> par frame (chaque <em>command buffer</em> coûtant 0.1 ms de charge GPU, voir plus). Cela peut nécessiter d’ajuster le nombre d’enregistrements concurrents des commandes de chaque passe, par exemple, si une passe d’ombre d’une lumière spécifique a moins de 100 <em>draw calls</em>, il peut être intéressant de n’enregistrer les commandes de cette passe que depuis un seul thread ; il peut même être intéressant de combiner les passes les plus courtes aux passes voisines, dans un unique <em>command buffer</em>. Au final, moins vous avez a de soumissions par frame, mieux c’est — en revanche, cela doit être équilibré par la soumission de suffisamment de travail GPU plus tôt dans la frame pour augmenter le parallélisme CPU et GPU, par exemple, il peut être judicieux de soumettre tous les <em>command buffers</em> du rendu des ombres avant d’enregistrer les commandes pour les autres parties de la frame.</p>
<p>Surtout, le nombre de soumissions fait référence au nombre total de structures <code>VkSubmitInfo</code> soumis par tous les appels à <code>vkQueueSubmit</code> d’une frame, et non simplement au nombre d’appel à <code>vkQueueSubmit</code>. Par exemple, lors de la soumission de 10 <em>command buffer</em>, il est beaucoup plus efficace d’utiliser un seul <code>VkSubmitInfo</code> soumettant 10 <em>command buffers</em> plutôt que 10 <code>VkSubmitInfo</code> avec un seul <em>command buffer</em> chacune, même si dans les deux cas, <code>vkQueueSubmit</code> n’est appelé qu’une fois. Fondamentalement, <code>VkSubmitInfo</code> est un bloc de synchronisation/planification sur GPU, car il possède son propre ensemble de clôtures/sémaphores.</p>
<h3 id="les-command-buffers-secondaires">Les <em>Command buffers</em> secondaires</h3>
<p>Quand une des passes de rendu de l’application contient beaucoup de <em>draw calls</em>, comme la passe <em>gbuffer</em>, il est important de découper les <em>draw calls</em> en plusieurs groupes et de les enregistrer depuis plusieurs threads. Il y a deux façons de faire :</p>
<ul>
<li>Utiliser <code>vkCmdBeginRenderPass</code> et <code>vkCmdEndRenderPass</code> pour enregistrer les <em>command buffers</em> primaires qui rendent les blocs de <em>draw calls</em> d’un même <em>framebuffer</em> ; et exécuter ces <em>command buffers</em> via <code>vkQueueSubmit</code> (en batch pour de bonnes performances).</li>
<li>Enregistrer des <em>command buffers</em> secondaires qui rendent des blocs de <em>draw calls</em>, en passant la passe de rendu à <code>vkBeginCommandBuffer</code> avec <code>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT</code> ; utilisez <code>vkCmdBeginRenderPass</code> avec <code>VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS</code> dans le <em>command buffer</em> principale, suivi de <code>vkCmdExecuteCommands</code> pour exécuter toutes les <em>command buffers</em> secondaires enregistrés.</li>
</ul>
<p>Bien que sur des GPUs en mode immédiat la première approche puisse être viable, et qu’il puisse être plus simple de gérer les points de synchronisation <code>wrt</code> sur le CPU, il est en revanche vital d’utiliser la seconde approche sur les GPUs utilisant le rendu en tuile. Utiliser la première approche sur les GPUs « à tuiles » impliquerait que le contenu de la tuile soit vidé puis rechargé de la mémoire entre chaque <em>command buffer</em>, ce qui est catastrophique du point de vue des performances.</p>
<h3 id="reutilisation-des-command-buffers">Réutilisation des <em>command buffers</em></h3>
<p>Avec les conseils sur la soumission des <em>command buffers</em> vues plus haut, dans la plupart des cas, il devient compliqué de soumettre un unique <em>command buffer</em> plusieurs fois après son enregistrement. En général, les approches consistant à pré-enregistrer les <em>command buffers</em> pour des pans de la scène sont contre-productives, car elles peuvent entraîner une charge excessive du GPU à cause du mauvais <em>culling</em> qu’elles impliquent, ce dernier étant requis pour garder une charge des <em>command buffers</em> élevée, et peuvent passer par des chemins de code inefficaces sur certains GPU à tuile. Au lieu de ça, les applications doivent se concentrer sur l’amélioration du threading et du coût de la soumission des <em>draw calls</em> sur le CPU. De fait, les applications devraient utiliser <code>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT</code> pour s’assurer que le pilote a la liberté de générer des commandes qui n’ont pas besoin d’être ré-exécutées plus d’une fois.</p>
<p>Il y a des exceptions à cette règle. Par exemple, pour le rendu VR, une application pourrait enregistrer le <em>command buffer</em> pour le frustum des deux yeux combinés en une seule fois. Si des données « par œil » sont lues depuis un unique <em>uniform buffer</em>, ce <em>buffer</em> peut alors être mis à jour entre les <em>command buffers</em> en utilisant <code>vkCmdUpdateBuffer</code>, suivi de <code>vkCmdExecuteCommands</code> si les <em>command buffers</em> secondaires sont utilisés, ou <code>vkQueueSubmit</code>. Cela dit, pour la VR il peut être intéressant de s’attarder sur l’extension <code>VK_KHR_multiview</code> si elle est disponible (dans core en 1.1), car elle devrait permettre au pilote d’effectuer une optimisation similaire.</p>
<h2 id="barrieres-de-pipeline">Barrières de pipeline</h2>
<p>Les barrières de pipeline restent l’un des concepts les plus difficiles du code Vulkan. Dans les API plus anciennes, le <em>runtime</em> et le pilote étaient chargés de s’assurer que la synchronisation appropriée, spécifique au matériel, était effectuée en cas de dangers tels que la lecture par le <em>fragment shader</em> d’une texture à l’intérieur de laquelle un rendu a été effectué précédemment. Cela nécessitait un suivi méticuleux du binding de chaque ressource dont il en résultait un mélange malheureux de surcharge CPU pour effectuer une quantité parfois excessive de synchronisation du GPU (par exemple, un pilote Direct3D 11 insère généralement une barrière entre deux dispatches de calculs consécutifs utilisant le même UAV, même si selon la logique de l’application, les dangers peuvent être absents). Dans la mesure ou l’insertion rapide et optimale des barrières implique de comprendre comment l’application utilise les ressources, Vulkan demande à l’application de le faire.</p>
<p>Pour un rendu optimal, la mise en place des barrières de pipeline doit être parfaite. Une barrière manquante fait courrir le risque à l’application de rencontrer un bogue dépendant du timing sur une architecture non testée — ou, pire, encore inexistante — qui, dans le pire des cas, pourrait provoquer un crash du GPU. Une barrière inutile peut diminuer l’utilisation du GPU en réduisant les potentielles exécutions en parallèle —  ou, pire, déclencher des opérations de décompression coûteuses, etc. Pour rendre le tout plus dur, alors que le coût des barrières excessives peut désormais être visualisé par des outils tels que <em>Radeon Graphics Profiler</em>, les barrières manquantes ne sont généralement pas détectées par les outils de validation.</p>
<p>Pour ces raisons, il est essentiel de comprendre le comportement des barrières, les conséquences d’une utilisation abusive ainsi que la manière de les utiliser.</p>
<h3 id="modele-mental_2">Modèle mental</h3>
<p>La spécification décrit la notion de barrières comme des dépendances d’exécution et de visibilité de la mémoire entre les étapes du pipeline (e.g. une ressource a été précédemment écrite par une étape de <em>compute shader</em>, et sera lu par l’étape de transfert), ainsi que les changements d’agencement des images (e.g. une ressource était auparavant dans le format optimal pour écrire via la sortie de l’attachement de couleur et sera transféré vers un format optimal pour lire à partir du shader). Cependant, il peut être plus facile de penser les barrières en fonction de leurs conséquences — c.à.d ce qui peut arriver sur un GPU lorsqu’une barrière est utilisée. Notez que le comportement du GPU dépend bien sûr des spécificités du fabricant et de l’architecture, mais faire une relation entre les barrières spécifiées de façon abstraite et des constructions plus concrètes aide à comprendre leurs implications en termes de performances.</p>
<p>Une barrière peut provoquer trois choses différentes :</p>
<ol>
<li>Bloquer l’exécution d’une étape spécifique le temps qu’une autre étape soit vidé de tout travail en cours. Par exemple, si une passe rend des données dans une texture, et qu’une passe ultérieure y lit les informations via un <em>vertex shader</em>, le GPU doit attendre que tous les <em>fragment shaders</em> et <em>ROP</em><sup id="fnref:8"><a class="footnote-ref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fn:8">8</a></sup> soient terminés avant de lancer les threads du <em>vertex shader</em> dans la passe qui suit. La plupart des opérations de barrière entraîneront un blocage de l’exécution de certaines étapes<sup id="fnref:9"><a class="footnote-ref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fn:9">9</a></sup>.</li>
<li>Vider ou invalider un cache interne côté GPU et attendre la fin des transactions mémoire pour s’assurer qu’une autre étape peut lire le travail résultant. Par exemple, sur certaines architectures, les écritures <em>ROP</em> peuvent passer par le cache de texture L2, mais l’étape de transfert peut opérer directement sur la mémoire. Si une texture a été rendue dans une passe de rendu, l’opération de transfert suivante peut lire des données périmées à moins que le cache ne soit vidé avant la copie. De même, si une étape de texture a besoin de lire une image qui a été copiée à l’aide de l’étape de transfert, le cache de texture L2 peut devoir être invalidé pour s’assurer qu’il ne contient pas de données périmées. Peu d’opérations de barrière auront besoin de faire ça.</li>
<li>Convertir le format dans lequel la ressource est stockée, le plus souvent pour décompresser le stockage des ressources. Par exemple, sur certaines architectures, les textures MSAA sont stockées sous une forme compressée où chaque pixel à un masque d’échantillon indiquant le nombre de couleurs uniques que contient ce pixel,  et un stockage séparé pour les données d’échantillon. L’étape de transfert ou de shader peut être incapable de lire directement à partir d’une texture compressée, donc une barrière qui transite de <code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code> à <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code> ou <code>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</code> pourrait avoir besoin de décompresser la texture, écrire tous les échantillons de tous les pixels dans la mémoire. La plupart des opérations de barrières n’auront pas besoin faire cela, mais celles qui le font peuvent être extrêmement coûteuses.</li>
</ol>
<p>Avec ça en tête, essayons de comprendre la façon d’utiliser des barrières.</p>
<h3 id="obtenir-les-meilleures-performances">Obtenir les meilleures performances</h3>
<p>Lors de la génération des commandes de chaque barrière, le pilote n’a qu’une vision locale de la barrière et n’est pas conscient des barrières précédentes et à vernir. Pour cette raison, la règle numéro 1 est que les barrières doivent être regroupées aussi agressivement que possible. Supposons une barrière impliquant l’attente d’inactivité de l’étape du <em>fragment shader</em> et un vidage du cache L2 des textures, le pilote générera consciencieusement cela chaque fois que vous appelez <code>vkCmdPipelineBarrier</code>. Si vous spécifiez plusieurs ressources dans un seul appel à <code>vkCmdPipelineBarrier</code>, le pilote ne générera qu’une seule commande de vidage du cache de texture L2 si elle est nécessaire à une transition, ce qui réduit le coût.</p>
<p>Pour être sûr que le coût des barrières n’est pas plus élevé qu’il ne devrait l’être, seuls les étapes pertinentes doivent être incluses. Par exemple, un des types de barrière le plus courant est celui faisant transiter une ressource de <code>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</code> vers <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>. Quand on spécifie cette barrière, on doit spécifier quelles étapes de shader liront réellement cette ressource, via <code>dstStageMask</code>. Il est tentant de spécifier le masque des étapes à <code>VK_PIPELINE_STAGE_ALL_COMMANDS_BIT</code> pour pouvoir lire depuis un <em>compute shader</em> ou un <em>vertex shader</em>. Faire ça implique cependant que le travail du <em>vertex shader</em> des commandes de <em>draw</em> à venir ne pourra pas démarrer, ce qui est problématique :</p>
<ul>
<li>Dans les moteurs de rendu en mode immédiat, cela réduit légèrement le parallélisme entre les <em>draw calls</em>, exigeant que tous les threads de <em>fragment</em> soient terminés avant que ceux de <em>vertex</em> ne puisse commencer, ce qui entraîne une utilisation GPU tombant à 0 à la fin d’une passe puis passant progressivement de 0 à, espérons-le, 100 % au début de la prochaine passe de rendu ;</li>
<li>Dans les moteurs de rendu en tuile, sur certaines conceptions on s’attend à ce tous les travaux du <em>vertex shader</em> de la passe à venir s’exécute jusqu’à la fin avant que le travail du <em>fragment shader</em> ne puisse commencer ; attendre la fin du travail du <em>fragment shader</em> avant de commencer celui du <em>vertex shader</em> élimine complètement le parallélisme entre l’étape du <em>vertex shader</em> et celle du <em>fragment shader</em> et est l’un des problèmes de performance potentiel le plus important qu’un portage de titre natif Vulkan puisse rencontrer.</li>
</ul>
<p>Notez que même si les barrières sont spécifiées correctement — dans notre cas, à supposer que la texture soit lue à partir de l’étape de <em>fragment shader</em>, <code>dstStageMask</code> doit être <code>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</code> — la dépendance d’exécution est toujours présente, et elle risque d’entraîner une utilisation réduite du GPU. Cela peut survenir dans plusieurs situations y compris le <em>compute shader</em>, où pour lire, depuis un <em>compute shader</em>, les données générées par un autre <em>compute shader</em>, vous devez exprimer une dépendance d’exécution entre CS et CS, mais spécifier une barrière de pipeline garantis de vider entièrement le GPU du travail du premier <em>compute shader</em>, pour ensuite le remplir de nouveau, lentement, de travail du second <em>compute shader</em>. Au lieu de ça, il peut être intéressant de spécifier la dépendance en utilisant ce qu’on appelle une barrière divisée : Au lieu d’utiliser <code>vkCmdPipelineBarrier</code>, utilisez <code>vkCmdSetEvent</code> une fois l’opération d’écriture terminée, et <code>vkCmdWaitEvents</code> avant que les opérations de lecture ne commencent. Bien entendu, <code>vkCmdWaitEvents</code> immédiatement après <code>vkCmdSetEvent</code> est contre-productif et peut être plus lent que <code>vkCmdPipelineBarrier</code> ; au lieu de ça, vous devriez restructurer votre algorithme pour vous assurer qu’il y a suffisamment de travail soumis entre <code>Set</code> et <code>Wait</code>, de sorte qu’au moment où le GPU doit traiter <code>Wait</code>, l’événement est probablement déjà signalé et il n’y a pas de perte d’efficacité.</p>
<p>Alternativement, dans certains cas, l’algorithme peut être restructuré pour réduire le nombre de points de synchronisation tout en utilisant des barrières de pipeline, diminuant la surcharge. Par exemple, une simulation de particules sur GPU peut avoir besoin d’exécuter deux <em>compute shader</em> pour chaque effet de particule : Un pour émettre de nouvelles particules et une autre pour simuler les particules. Ces envois nécessitent une barrière de pipeline entre eux pour synchroniser l’exécution, ce qui nécessite une barrière de pipeline par système de particules si les systèmes de particules sont simulés séquentiellement. Une meilleure implémentation soumettrait d’abord tous les <em>compute shader</em> d’émission de particules (chose ne dépendant pas les unes des autres), puis soumettrait une barrière pour synchroniser l’envoi des émissions et de simulation, puis soumettrait tous les envois pour simuler les particules — ce qui garderait le GPU bien utilisé plus longtemps. À partir de là, l’utilisation de barrières séparées pourrait aider à masquer complètement le coût de synchronisation.</p>
<p>En ce qui concerne la décompression des ressources, il est difficile de donner un conseil général — sur certaines architectures, cela ne se produit jamais, et ça arrive sur d’autres, mais selon l’algorithme, cela peut être inévitable. L’utilisation d’outils spécifiques au fournisseur tels que <em>Radeon Graphics Profiler</em> est essentielle pour comprendre l’impact de la décompression sur les performances sur votre frame ; dans certains cas, il peut être possible d’ajuster l’algorithme pour ne pas exiger la décompression immédiatement, par exemple en déplaçant le travail à une étape différente. Bien sûr, il convient de noter que la décompression des ressources peut se produire dans les cas où elle est totalement inutile et est le résultat de barrières « surspécifiées » — par exemple, si vous effectuez un rendu dans un <em>framebuffer</em> contenant un <em>depth buffer</em>, mais ne lisez jamais le contenu de <em>depth</em>, vous devriez laisser l’agencement du <em>depth buffer</em> à <code>VK_IMAGE_LAYOUT_DEPTH_STENCIL_OPTIMAL</code> au lieu de le faire passer inutilement dans <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code> qui pourrait déclencher une décompression (gardez à l’esprit que le pilote ne sait pas si vous allez lire la ressource).</p>
<h3 id="simplifier-la-specification-des-barrieres">Simplifier la spécification des barrières</h3>
<p>Avec toute la complexité qu’implique la spécification des barrières, il est utile d’avoir des exemples de barrières couramment utilisées. Heureusement, <em>Khronos Group</em> fournit de nombreux exemples de barrières pertinentes et optimales pour divers types de synchronisation dans le <a href="https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples">repo de documentation de Vulkan sur GitHub</a>. Ces exemples peuvent servir à améliorer la compréhension du comportement général des barrières et peuvent également être utilisés directement dans une application.</p>
<p>De plus, pour les cas non couverts par ces exemples et, en général, pour simplifier le code de spécification et le rendre plus correct, il est possible de passer à une approche plus simple où, au lieu de spécifier l’intégralité des masques d’accès, d’étapes et des agencements d’images, le seul concept à connaître relatif à une ressource est l’état de la ressource encapsulant les étapes qui peuvent l’utiliser et le mode d’utilisation des types d’accès les plus courants. De là, toutes les transitions impliquent la transition d’une ressource de l’état A à l’état B, ce qui est beaucoup plus facile à comprendre. À cette fin, Tobias Hector, membre du <em>Khronos Group</em> et co-auteur de la spécification Vulkan, a écrit une bibliothèque open-source, <a href="https://github.com/Tobski/simple_vulkan_synchronization">simple_vulkan_synchronization</a>, qui traduit les transitions de l’état des ressources (appelé « <em>access type</em> » dans la bibliothèque) en spécification de barrière Vulkan. La bibliothèque est petite et simple et prend en charge les barrières divisées ainsi que l’intégralité des barrières de pipeline.</p>
<h3 id="predire-lavenir-avec-des-graphs-de-rendu">Prédire l’avenir avec des graphs de rendu</h3>
<p>Les optimisations de la section précédente sont difficiles à appliquer compte tenu des architectures en mode immédiat qu’on rencontre généralement.</p>
<p>Pour s’assurer que les étapes et les transitions d’agencement d’image ne sont pas sur-spécifiées, il est important de savoir comment la ressource est amenée à être utilisé — si vous souhaitez mettre une barrière de pipeline après une passe de rendu, sans ces informations, vous êtes généralement obligé de mettre une barrière avec toutes les étapes dans le masque d’étape de destination, et un agencement cible inefficace.</p>
<p>Pour résoudre ce problème, il est tentant de mettre les barrières <em>avant</em> de lire la ressource, car à ce stade, il est possible de savoir comment il a été écrit dans la-dite ressource ; cela rend cependant les barrières difficiles à grouper. Par exemple, dans une image avec 3 passes de rendu, A, B et C, où C lit la sortie de A et la sortie de B dans deux <em>draw calls</em> séparés, pour minimiser le nombre de vidages de cache de texture et d’autres travaux de barrière, il est généralement avantageux de spécifier une barrière avant C qui transite correctement les sorties de A et de B ; au lieu de cela, on pourrait mettre une barrière <em>avant</em> chacun des <em>draw calls</em> de C. Dans certains cas, séparer les barrières peut réduire leur coût, mais en général, une telle méthode est trop coûteuse.</p>
<p>De plus, l’utilisation de telles barrières nécessite le suivi de l’état de la ressource pour connaître l’agencement précédent ; c’est très difficile à faire correctement dans un système multi-threadé, car l’ordre d’exécution final sur le GPU ne peut être connu qu’une fois toutes les commandes enregistrées et linéarisées.</p>
<p>Pour toutes ces raisons, de nombreux moteurs de rendu modernes commencent à expérimenter les graphes de rendu comme moyen de spécifier de manière déclarative toutes les dépendances entre les ressources d’une frame. Suivant la structure DAG qui en résulte, il est possible d’établir des barrières correctes, y compris les barrières requises pour la synchronisation entre plusieurs files d’attentes, et d’allouer des ressources transitoires avec une utilisation minimale de la mémoire physique.</p>
<p>Cet article n’a pas pour vocation de faire une description complète d’un système de graphes de rendu, mais les lecteurs intéressés sont encouragés à se référer aux exposés et articles suivants :</p>
<ul>
<li><a href="https://www.gdcvault.com/play/1024612/FrameGraph-Extensible-Rendering-Architecture-in">FrameGraph: Extensible Rendering Architecture in Frostbite</a>, Yuriy O’Donnell, GDC 2017</li>
<li><a href="https://www.gdcvault.com/play/1024656/Advanced-Graphics-Tech-Moving-to">Advanced Graphics Tech: Moving to DirectX 12: Lessons Learned</a>, Tiago Rodrigues, GDC 2017</li>
<li><a href="http://themaister.net/blog/2017/08/15/render-graphs-and-vulkan-a-deep-dive/">Render graphs and Vulkan — a deep dive</a>, Hans-Kristian Arntzen</li>
</ul>
<p>Chaque moteur choisi en fonction de ses particularités, par exemple, le graph de rendu de Frostbite est spécifié par l’application en utilisant l’ordre d’exécution final (que l’auteur de cet article trouve plus prévisible et préférable), tandis que les deux autres présentations linéarisent le graph suivant certaines heuristiques pour essayer de trouver le meilleur ordre d’exécution possible. Quoi qu’il en soit, ce qu’il faut retenir c’est que les dépendances entre les passes sont être déclarées à l’avance pour la frame entière afin de s’assurer que les barrières peuvent être émises de manière appropriée. Surtout, les systèmes de graphe de frame fonctionnent bien pour les ressources transitoires qui sont limitées en nombre et représentent l’essentiel des barrières requises ; bien qu’il soit possible de spécifier dans un même système les barrières requises au chargement des ressources et autres opérations de streaming, ceci peut rendre les graphes trop complexes et le temps de traitement trop long, il est donc préférable de les gérer en dehors d’un système de graphe de frame.</p>
<h2 id="les-passes-de-rendu">Les passes de rendu</h2>
<p>Le concept de passe de rendu est unique à Vulkan comparé aux APIs précédentes (les plus anciennes comme les nouvelles). Les passes de rendu permettent à l’application représenter le rendu de leur frame en tant qu’objet à part entière, en découpant la charge de travail en sous-passes individuelles et en énumérant explicitement les dépendances entre ces sous-passes, permettant au pilote de planifier le travail et placer les commandes de synchronisation appropriées. En ce sens, les passes de rendu sont similaires aux graphes de rendu décrits ci-dessus et peuvent être utilisées pour les implémenter avec certaines limitations (par exemple, seuls les étapes de rastérisation peuvent être exprimées en passes de rendu, ce qui signifie que plusieurs passes de rendu sont nécessaires si vous devez utiliser des étapes de calcul). Cette section se concentrera sur les usages des passes de rendu les plus simples, plus pratiques à intégrer dans les moteurs de rendu existants, tout en offrant des avantages en termes de performances.</p>
<h3 id="les-operations-load-et-store">Les opérations <em>load</em> et <em>store</em></h3>
<p>L’une des fonctionnalités les plus importantes des passes de rendu est la possibilité de spécifier les opérations <em>load</em> et <em>store</em> (chargement et stockage). L’application peut les utiliser pour choisir si le contenu de chaque <em>framebuffer</em> attaché doit être vidé, chargé depuis la mémoire (<em>load</em>), ou rester non spécifié et inutilisé, et si, une fois la passe de rendu terminée, le <em>framebuffer</em> attaché doit être stockée en mémoire (<em>store</em>).</p>
<p>Il est important d’utiliser correctement ces opérations — sur des architectures en tuile, l’utilisation redondante d’opérations de chargement ou de stockage entraîne un gaspillage de bande passante, ce qui réduit les performances et augmente la consommation d’énergie. Sur les architectures « non tuilées », le pilote pourra toujours les utiliser pour effectuer certaines optimisations des rendus ultérieurs — par exemple, si un contenu précédent d’un <em>framebuffer</em> attaché n’est plus pertinent, mais qu’il a des métadonnées de compression associées, le pilote peut effacer ces métadonnées pour accélérer le rendu ultérieur.</p>
<p>Il est important d’utiliser les opérations <em>load</em> et <em>store</em> le plus granulairement possible afin de laisser plus de liberté au pilote — par exemple, quand on rend un quad en plein écran sur un <em>framebuffer</em> attaché (ce qui revient à écrire tous les pixels), il est probable que <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code> soit plus rapide que <code>VK_ATTACHMENT_LOAD_OP_LOAD</code> sur les GPU tuilés, et il est probable que <code>OP_LOAD</code> soit plus rapide sur les GPU en mode immédiat — spécifier <code>VK_ATTACHMENT_LOAD_OP_DONT_CARE</code> est important pour permettre au pilote de faire un choix optimal. Dans certaines situations, <code>OP_DONT_CARE</code> est meilleur que <code>OP_LOAD</code> ou <code>OP_CLEAR</code>, car il permet au pilote d’éviter une coûteuse opération de nettoyage du contenu, tout en effaçant quand-même les métadonnées d’image pour accélérer le rendu à venir.</p>
<p>À ce titre, <code>VK_ATTACHMENT_STORE_OP_DONT_CARE</code> doit être utilisé si l’application ne compte pas lire les données rendues dans le <em>frame buffer</em> attaché — c’est généralement le cas pour les <em>depth buffers</em> et les cibles MSAA.</p>
<h3 id="resolution-rapide-du-msaa">Résolution rapide du MSAA</h3>
<p>Après avoir rendu les données dans une texture MSAA, il est courant de les résoudre dans une texture non-MSAA pour un traitement ultérieur. Si résolution en fonction fixe est suffisante, il existe deux façons de l’implémenter dans Vulkan :</p>
<ul>
<li>En utilisant <code>VK_ATTACHMENT_STORE_OP_STORE</code> sur la texture MSAA et <code>vkCmdResolveImage</code> une fois la passe de rendu terminée.</li>
<li>En utilisant <code>VK_ATTACHMENT_STORE_OP_DONT_CARE</code> sur la texture MSAA et en indiquant la cible de la résolution via le membre <code>pResolveAttachments</code> de <code>VkSubpassDescription</code>.</li>
</ul>
<p>Dans ce dernier cas, le pilote effectuera le travail nécessaire à la résolution du MSAA dans le cadre du travail effectué quand les sous-passes/passes de rendu sont terminées.</p>
<p>La deuxième approche peut être beaucoup plus efficace. Sur les architectures en tuile, la première approche nécessite de stocker la totalité de la texture MSAA dans la mémoire principale, puis de la lire depuis cette mémoire et de la résoudre vers la destination ; la deuxième approche peut résolution directement « en tuile » de manière plus efficace. Sur les architectures en mode immédiat, il se peut que certaines implémentations ne prennent pas en charge la lecture des textures MSAA compressées via l’étape de transfert — l’API nécessite une transition vers la disposition <code>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</code> avant d’appeler <code>vkCmdResolveImage</code>, ce qui peut entraîner la décompression de la texture MSAA, gaspillant de la bande passante et des performances. Avec <code>pResolveAttachments</code>, le pilote peut effectuer l’opération de résolution avec des performances maximales quelle que soit l’architecture.</p>
<p>Dans certains cas, la résolution MSAA en fonction fixe est insuffisante. Il est alors nécessaire de faire transiter la texture vers <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code> et d’effectuer la résolution dans une passe de rendu séparée. Sur les architectures en tuile, cela présente les mêmes problèmes d’efficacité que la méthode en fonction fixe <code>vkCmdResolveImage</code> ; sur les architectures en mode immédiat, l’efficacité dépend du GPU et du pilote. Une alternative possible consiste à utiliser un sous-passe supplémentaire qui lit la texture MSAA via un <em>framebuffer</em> attaché.</p>
<p>Pour que cela fonctionne, la première sous-passe qui rend dans texture MSAA doit spécifier cette dernière via <code>pColorAttachments</code>, combiné à l’opération <code>VK_ATTACHMENT_STORE_OP_DONT_CARE</code>. La seconde sous-passe, qui effectue la résolution, doit spécifier la texture MSAA via <code>pInputAttachments</code> et la cible de la résolution via <code>pColorAttachments</code> ; la sous-passe doit alors rendre un quad (ou un triangle) en plein écran avec un shader utilisant la ressource <code>subpassInputMS</code> pour lire les données du MSAA. De plus, l’application doit spécifier une dépendance indiquant les masques d’étape/d’accès entre les deux sous-passes, au même titre que les barrières de pipeline, et les indicateurs de dépendances <code>VK_DEPENDENCY_BY_REGION_BIT</code>. Le pilote dispose alors de suffisamment d’informations pour organiser l’exécution de façon à ce que, sur les GPUs en tuile, les données MSAA ne quittent jamais la mémoire en tuile et que la résolution s’y fasse directement, le résultat de la résolution étant écrit dans la mémoire principale<sup id="fnref:10"><a class="footnote-ref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fn:10">10</a></sup>. Notez que ce comportement dépend du pilote et qu’il est peu probable que cela entraîne des économies significatives sur les GPU en mode immédiat.</p>
<h2 id="les-pipeline-objects">Les <em>pipeline objects</em></h2>
<p>Les anciennes APIs avait pour habitude de diviser les états du GPU en blocs suivant leur fonction —  par exemple, en Direct3D 11, l’état complet des modules GPU des <em>bindings</em> des ressources peut être décrit à l’aide d’un ensemble d’objets de shader pour différentes étapes (VS, PS, GS, HS, DS) ainsi qu’un ensemble d’objets d’états (<em>rasterizer</em>, <em>blend</em>, <em>depth stencil</em>), d’une configuration de l’assemblage d’entrée (<em>input layout</em>, <em>primitive topology</em>) et quelques autres bits <em>implicites</em> comme les formats de cible de sorti de rendu. L’utilisateur de l’API pouvait alors définir chaque bit d’état séparément, sans tenir compte de la conception ou de la complexité du matériel sous-jacent.</p>
<p>Malheureusement, cette approche ne correspond pas au matériel utilisé généralement, avec plusieurs problèmes de performances pouvant survenir :</p>
<ul>
<li>Bien que chaque objet d’état est supposé représenter une partie des états du GPU et puisse être directement transféré aux commandes configurant les états du GPU, sur certains GPUs, la configuration des états du GPU nécessite des données provenant de blocs d’états différents. Pour cela, les pilotes devaient généralement conserver une copie interne de tous les états puis les convertir en commandes GPU adaptées, au moment du <code>Draw</code>/<code>DrawIndexed</code>.</li>
<li>Avec le pipeline de rastérisation devenant plus complexe et ayant plus d’étapes programmable, certains GPUs ne mappaient pas directement les étapes exposées par les APIs aux étapes présentes sur le matériel, ce qui signifie que le microcode du shader pouvait dépendre de si d’autres étapes de shader sont activées et, dans certains cas, du microcode spécifique d’autres étapes ; cela signifiait que le pilote pouvait avoir à compiler un nouveau microcode de shader à partir d’un état qui ne peut être découvert qu’au moment de <code>Draw</code>/<code>DrawIndexed</code>.</li>
<li>De même, sur certains GPU, des unités fonctionnelles fixes tel que décrites par l’API ont été implémentées sous la forme d’une étape de shader — la modification du format d’entrée des sommets, la configuration des opérations de <em>blend</em>, ou du format de la cible de rendu pouvait affecter le microcode du shader. Comme l’état n’est connu qu’au moment du <code>Draw</code>/<code>DrawIndexed</code>, c’est là encore que le microcode final devait être compilé.</li>
</ul>
<p>Bien que le premier problème soit bénin, le second et le troisième peuvent entraîner des blocages importants lors du rendu car, en raison de la complexité des shaders modernes et des pipelines de compilation de shader, la compilation des shader pouvait prendre des dizaines, voir des centaines de milliseconds suivant le matériel. Pour résoudre cela, Vulkan et les autres nouvelles APIs introduisirent le concept de <em>pipeline object</em> — il encapsule la plupart des états du GPU, y compris le format d’entrée des sommets, le format de la cible de rendu, l’état de toutes les étapes et les modules de shader pour toutes les étapes. L’objectif étant que sur chaque GPU pris en charge, ces états soient suffisants pour créer le microcode du shader final et les commandes GPU nécessaires à la configuration des états, de sorte que le pilote n’ait jamais à compiler le microcode au moment du <em>draw</em> et puisse optimiser autant que possible la configuration du <em>pipeline object</em>.</p>
<p>En revanche, cette approche apporte son lot de difficultés quand on implémente un moteur de rendu s’appuyant sur Vulkan. Il y a plusieurs façons de résoudre ces problèmes, avec différents compromis en termes de complexité, d’efficacité et de conception sur le moteur de rendu.</p>
<h3 id="compilation-a-la-volee">Compilation à-la-volée</h3>
<p>Le moyen le plus simple de prendre en charge Vulkan est d’utiliser la compilation à la volée pour les objets de pipeline. Dans de nombreux moteurs, en raison du manque de concepts correspondant à Vulkan, le <em>backend</em> de rendu doit collecter des informations sur différentes parties de l’état du pipeline suivant divers appels de configuration d’état, de la même manière qu’un pilote Direct3D 11 pourrait faire. Puis, avant le <em>draw/dispatch</em> où l’intégralité des états sont connus, les bits de chacun des états sont groupés et recherchés dans une table de hash ; s’il y a déjà un objet d’état de pipeline dans le cache, il peut être utilisé directement, sinon un nouvel objet peut être créé.</p>
<p>Cette approche fonctionne pour faire tourner votre application, mais souffre de deux problèmes de performances.</p>
<p>Une préoccupation mineure est que les états à hacher sont potentiellement gros ; faire cela pour chaque <em>draw call</em> peut prendre du temps lorsque le cache contient déjà tous les objets pertinents. Cela peut être atténué en regroupant les états en objets et en hachant les pointeurs vers ces objets, et en général en simplifiant la représentation des états du point de vue d’une l’API plus haut niveau.</p>
<p>Un problème important est que pour tout objet d’état de pipeline à créer, le pilote risque de devoir compiler plusieurs shaders vers le microcode GPU final. Ce traitement prend du temps ; de plus, il ne peut pas être threadé efficacement par une approche de compilation à-la-volée — si une application utilise un thread pour la soumission des commandes, ce thread devra généralement également compiler les objets d’état du pipeline ; même avec plusieurs threads, souvent, ils solliciteraient le même <em>pipeline object</em>, ce qui sérialiserait la compilation, ou un thread aurait besoin de plusieurs nouveaux objets de pipeline, ce qui augmente la latence globale de la soumission puisque les autres threads finiraient en premier et n’auraient aucun travail à faire.</p>
<p>Pour la soumission multi-threaded, l’accès au cache peut entraîner des conflits entre les cœurs, même si le cache est plein. Heureusement, cela peut être résolu par un cache à deux niveaux comme suit :</p>
<p>Le cache aurait deux parties, la partie immuable qui ne change jamais durant la frame, et la partie mutable. Pour effectuer une recherche dans le cache de pipeline, on regarde d’abords si l’objet est dans le cache immuable — cela se fait sans aucune synchronisation. S’il n’y est pas, on verrouille une section critique<sup id="fnref:11"><a class="footnote-ref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fn:11">11</a></sup> et on vérifie qu’il est dans le cache mutable ; s’il n’y est toujours pas, on déverrouille la section critique, on créé le <em>pipeline object</em>, puis on la re-verrouille et on insère l’objet dans le cache, en déplaçant potentiellement un autre objet (une synchronisation supplémentaire ou peut être nécessaire si, lorsque deux threads demande le même objet, seul une demande de compilation est envoyée au pilote).</p>
<p>À la fin de la frame, tous les objets du cache mutable sont ajoutés au cache immuable, et le cache mutable est vidé, de sorte que lors de la prochaine frame, les accès à ces objets puissent être threadé.</p>
<h3 id="cache-de-pipeline-et-prechauffage-du-cache">Cache de pipeline et préchauffage du cache</h3>
<p>Bien que la compilation à-la-volée puisse fonctionner, elle entraîne un <em>shuttering</em> important pendant le jeu. Dès qu’un objet avec un nouvel ensemble de shaders/états pénètre dans la frame, on se retrouve à devoir compiler son <em>pipeline object</em> ce qui peut être lent. C’est un problème similaire rencontré par les titres en Direct3D 11, mais avec cette API, les pilotes faisaient beaucoup de travail sous le capot pour essayer de masquer la latence de compilation, précompilant à l’avance certain shaders et implémentant des mécanismes d’injection de <em>bytecode</em> à-la-volée pour s’éviter une recompilation complète. Vulkan s’attend à ce que l’application gère manuellement et intelligemment la création d’objets de pipeline, de sorte qu’une approche naïve ne fonctionne pas très bien.</p>
<p>Afin de rendre la compilation à-la-volée plus pratique, il est important d’utiliser le cache de pipeline de Vulkan, de le sérialiser entre les exécutions, et de préchauffer le cache en mémoire décrit dans la section précédente au démarrage de l’application, à partir de plusieurs threads.</p>
<p>Vulkan fourni un objet de cache de pipeline, <code>VkPipelineCache</code>, qui peut contenir des bits d’état et un microcode de shader spécifiques au pilote pour améliorer le temps de compilation des objets de pipeline. Par exemple, si une application créée deux objets de pipeline avec des configurations identiques à l’exception du mode de <em>culling</em>, le microcode du shader est généralement le même. Pour s’assurer que le pilote ne compile l’objet qu’une seule fois, l’application doit transmettre la même instance de <code>VkPipelineCache</code> aux deux appels à <code>vkCreateGraphicsPipelines</code>, ce qui compilera le microcode du shader au premier appel et le réutilisera directement au second. Si ces appels se produisent simultanément dans différents threads, le pilote risque de compiler les shaders deux fois, car les données ne sont ajoutées au cache qu’à la fun de l’un des appels.</p>
<p>Il est vital d’utiliser le même objet <code>VkPipelineCache</code> quand on crée tous les objets de pipeline et de le sérialiser sur le disque entre les exécutions via <code>vkGetPipelineCacheData</code> et le membre <code>pInitialData</code> de <code>VkPipelineCacheCreateInfo</code>. Cela garantit que les objets compilés sont réutilisés entre les exécutions et minimise variations de FPS lors des exécutions ultérieures de l’application.</p>
<p>Malheureusement, les pics de compilation de shader se produiront quand même lors de la première partie, car le cache de pipeline ne contiendra pas toutes les combinaisons utilisées. De plus, même lorsque le cache du pipeline contient les microcodes nécessaires, <code>vkCreateGraphicsPipelines</code> reste coûteux et, par conséquent, la compilation de nouveaux objets de pipeline peut toujours augmenter la variance de la durée des frames. Pour résoudre ce problème, il est possible de préchauffer le cache en mémoire (et/ou <code>VkPipelineCache</code>) pendant le temps de chargement.</p>
<p>Une solution envisageable est qu’à la fin de la session de jeu, le moteur de rendu enregistre les données de cache du pipeline présentes en mémoire — quels shaders étaient utilisés avec quels états<sup id="fnref:12"><a class="footnote-ref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fn:12">12</a></sup> — dans une base de données. Puis, pendant les sessions de jeu de contrôle qualité, cette base de donnée pourrait être remplie par plusieurs sessions de jeu à différents paramètres graphiques, etc — rassemblant efficacement l’ensemble des états susceptibles d’être utilisés pendant une session de jeu réel.</p>
<p>Cette base de données peut ensuite être déployé avec le jeu ; au démarrage du jeu, le cache en mémoire est être préremplis par des états créés en utilisant les données de la base (ou, suivant la quantité d’état de pipeline, cette phase de préchauffage peut être limitée aux états des paramètres graphiques actuels). Dans l’idéal, cela devrait se faire sur plusieurs threads pour diminuer le temps de chargement ; la première exécution aurait toujours un temps de chargement plus long (qui peuvent être encore réduits avec des fonctionnalités telles que le <em>pre-caching</em> de Steam), mais les chutes de <em>frame rate</em> dus à la création de <em>pipeline objects</em> à-la-volée peuvent pratiquement tous être évités.</p>
<p>Si des combinaisons particulières d’états n’ont pu être découvertes pendant les sessions de jeu de contrôle qualité, le système fonctionnera toujours — au pris d’un léger <em>shuttering</em>. Cette approche est plus ou moins universelle et pratique — mais nécessite un effort potentiel pour jouer à travers suffisamment de niveaux avec suffisamment de paramètres graphiques différents pour « capturer » les situations les plus réalistes, ce qui la rend quelque peu difficile à gérer.</p>
<h3 id="compilation-davance">Compilation d’avance</h3>
<p>La solution « parfaite » — celle pour laquelle Vulkan a été conçu — est de supprimer le cache de compilation à-la-volée et le préchauffage, et d’avoir simplement chaque objet pipeline possible, disponible à l’avance.</p>
<p>Ça implique en général de changer la conception du moteur de rendu et d’intégrer le concept d’état de pipeline dans le système de matériaux, permettant à un matériau de spécifier entièrement l’état. Il y a différentes approches possibles ; cette section n’en décrira qu’une seule, mais l’important est le principe général.</p>
<p>Un objet est généralement associé au matériau qui défini les états graphiques et les <em>bindings</em> de ressource nécessaire à son rendu. Dans ce cas, il est important de séparer les <em>bindings</em> de ressource des états graphiques, car l’objectif est de pouvoir énumérer toutes les combinaisons d’état graphique à l’avance. Appelons la collection d’états graphiques une « technique » (cette terminologie est intentionnellement similaire à la terminologie de <em>Direct3D Effect Framework</em>, bien qu’ici, l’état est stocké dans la passe). Les <em>techniques</em> peuvent ensuite être groupées en effets, et un matériau ferait référence à l’effet, et à une sorte de clé désignant la <em>technique</em> de cet effet.</p>
<p>L’ensemble des effets et techniques qui les composent seraient statiques. Les effets ne sont pas aussi vitaux à la précompilation des objets de pipeline que les techniques, mais peuvent servir à grouper sémantiquement les techniques — par exemple, souvent un matériau se voit assigné d’un effet au moment de sa création, mais la technique peut varier suivant où l’objet est rendu (e.g. passe d’ombre, passe de <em>gbuffer</em>, passe de réflexion) ou suivant les effets active du jeu (e.g. glow, bloom).</p>
<p>Fondamentalement, la technique doit spécifier tous les états requis pour créer un <em>pipeline object</em>, de manière statique, à l’avance — généralement dans le cadre d’une définition dans un fichier texte, que ce soit dans un DSL ressemblant à un D3DFX ou dans un fichier JSON/XML. Il doit inclure tous les shaders, les états de <em>blend</em>, les états <em>culling</em>, le format des sommets, les formats des cibles de rendu, l’état de <em>depth</em>. Voici un exemple de ce à quoi cela pourrait ressembler :</p>
<div class="highlight"><pre><span></span><span class="n">technique</span> <span class="n">gbuffer</span>
<span class="p">{</span>
    <span class="n">vertex_shader</span> <span class="n">gbuffer_vs</span>
    <span class="n">fragment_shader</span> <span class="n">gbuffer_fs</span>

<span class="cp">#ifdef DECAL</span>
    <span class="n">depth_state</span> <span class="n">less_equal</span> <span class="nb">false</span>
    <span class="n">blend_state</span> <span class="n">src_alpha</span> <span class="n">one_minus_src_alpha</span>
<span class="cp">#else</span>
    <span class="n">depth_state</span> <span class="n">less_equal</span> <span class="nb">true</span>
    <span class="n">blend_state</span> <span class="n">disabled</span>
<span class="cp">#endif</span>

    <span class="n">render_target</span> <span class="mi">0</span> <span class="n">rgba16f</span>
    <span class="n">render_target</span> <span class="mi">1</span> <span class="n">rgba8_unorm</span>
    <span class="n">render_target</span> <span class="mi">2</span> <span class="n">rgba8_unorm</span>

    <span class="n">vertex_layout</span> <span class="n">gbuffer_vertex_struct</span>
<span class="p">}</span>
</pre></div>


<p>En partant du principe que tous les <em>draw calls</em>, y compris ceux de <em>post-processing</em>, etc, utilise le mécanisme des effets pour spécifier les états de rendu, et en assumant que l’ensemble des effets et techniques est statique, il est facile de pré-créer tous les objets de pipeline — chaque technique n’en nécessitant qu’un seul — au moment du chargement, en utilisant plusieurs threads, et d’utiliser un code très efficace au moment de l’exécution du programme, sans nécessiter d’avoir des caches en mémoire ou risquer des chutes de <em>framerate</em>.</p>
<p>En pratique, implémenter ce système dans un moteur de rendu moderne est un exercice de gestion de la complexité. Il est courant d’utiliser des shaders complexes ou des permutations d’états — par exemple, pour du rendu double-face on a généralement besoin de changer les états du <em>culling</em> et peut-être changer les shaders pour implémenter du lighting double-face. Pour le rendu de <em>skinning</em>, vous devez changer le format des sommets et ajouter du code au <em>vertex shader</em> pour transformer les attributs à l’aide de matrices de <em>skin</em>. Sur certaines configurations graphiques, on peut décider de que le format de cible de rendu doit être en virgule-flottante <code>R10G11B10</code> au lieu de <code>RGBA16F</code>, pour conserver de la bande passante. Toutes ces combinaisons se multiplient et nécessite que vous soyez capable de les représenter de manière concise et efficace lors de la spécification des données techniques (par exemple, en autorisant des sections <code>#ifdef</code> à l’intérieur des déclarations techniques comme indiqué ci-dessus), et — surtout — être conscient du nombre croissant de combinaisons et les refactoriser/simplifier le cas échéant. Certains effets sont suffisamment rares pour être rendu dans une passe séparée sans augmenter le nombre de permutations. Certains calculs sont assez simples de sorte que les exécuter systématiquement dans tous les shaders puisse être un meilleur compromis plutôt que d’augmenter le nombre de permutations. Et certaines techniques de rendu offrent un meilleur découplage et une meilleure séparation des préoccupations<sup id="fnref:13"><a class="footnote-ref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fn:13">13</a></sup>, ce qui peut également réduire le nombre de permutations.</p>
<p>Il est important de noter qu’ajouter la permutation d’états à l’ensemble complexifie le problème, mais ne le rend pas différent — de nombreux moteurs de rendu doivent de toute façon résoudre la problématique posée par le grand nombre de permutations de shaders, et une fois qu’on a incorporé tous les états de rendu dans la spécification des shaders/techniques et qu’on s’est concentré sur la réduction du nombre de permutations de techniques, les mêmes solutions de gestion de la complexité s’appliquent également aux deux problèmes. L’avantage d’implémenter un tel système est une parfaite connaissance de toutes les combinaisons requises (au lieu de s’appuyer sur des systèmes de découverte de permutation, fragiles), d’excellentes performances avec une variance minimale de durée entre les frames, y compris au premier chargement, et une fonction de forçage pour garder la complexité du code de rendu sous contrôle.</p>
<h2 id="conclusion">Conclusion</h2>
<p>L’API Vulkan déplace une grande part de la responsabilité du pilote vers l’application. Naviguer entre les fonctionnalités de rendu devient plus difficile aux vues des nombreuses d’implémentations disponibles ; il est déjà difficile d’écrire correctement un moteur de rendu Vulkan, mais les performances et la consommation de mémoire sont fondamentales. Cet article a tenté d’aborder plusieurs considérations importantes quand on se retrouve face à des problèmes spécifiques à Vulkan, a présenté plusieurs types d’implémentations visant un compromis entre la complexité, la facilité d’utilisation et les performances, et couvert un large éventail entre le portage de moteurs de rendu existants et leur re-conception à la lueur de Vulkan.</p>
<p>En fin de compte, il est difficile de donner un conseil général fonctionnant pour tous les fabricants et applicable à tous les moteurs de rendu. C’est la raison pour laquelle il est essentiel de profiler son code sur la plate-forme/le fabricant cible — avec Vulkan, il est important de monitorer les performances chez tous les fabricants pour lesquels on prévoit de livrer le jeu, car les choix que fait l’application sont primordiaux, et dans certains cas, une fonction bien spécifique, comme le <em>binding</em> des <em>vertex buffers</em> en fonction fixe, est l’approche la plus rapide chez un fabricant, mais la plus lente chez un autre.</p>
<p>En plus d’utiliser les couches de validation s’assurant de l’exactitude du code et des outils de profilage spécifiques aux fabricants, tel que le <em>AMD Radeon Graphics Profiler</em> ou le <em>NVidia Nsight Graphics</em>, de nombreuses bibliothèques open-source permettant de vous aider à optimiser votre moteur de rendu pour Vulkan sont disponibles :</p>
<ul>
<li>
<p><a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">VulkanMemoryAllocator</a> — fournit des allocateurs de mémoire pratiques et performants pour Vulkan ainsi que des algorithmes de gestion de mémoire tels que la défragmentation.</p>
</li>
<li>
<p><a href="https://github.com/zeux/volk">volk</a> — fournit un moyen simple d’utiliser directement les points d’entrée Vulkan fournis par le pilote, ce qui peut réduire la surcharge des appels de fonction.</p>
</li>
<li>
<p><a href="https://github.com/Tobski/simple_vulkan_synchronization">simple_vulkan_synchronization</a> — fournit un moyen de spécifier les barrières Vulkan à l’aide de types d’accès simplifiés, ce qui aide à équilibrer la complexité du code avec les performances.</p>
</li>
<li>
<p><a href="https://github.com/ValveSoftware/Fossilize">Fossilize</a> — ajoute la sérialisation de divers objets Vulkan, notamment les informations de création d’état de pipeline qui peuvent servir à gérer le préchauffage d’un cache de pipeline.</p>
</li>
<li>
<p><a href="https://github.com/ARM-software/perfdoc">perfdoc</a> — ajoute une couche de validation, qui analysent le flux de la commande de rendu et identifient les problèmes de performances potentiels sur les GPUs ARM.</p>
</li>
<li>
<p><a href="https://github.com/zeux/niagara">niagara</a> — fournit un exemple de moteur de rendu <em>bindless</em> appliquant certains des conseils de cet article (mais pas tous !).</p>
</li>
<li>
<p><a href="https://github.com/khronosGroup/Vulkan-samples">Vulkan-Samples</a> — fournit de nombreux exemples explorant les divers compromis dans l’implémentation des techniques de rendu Vulkan ainsi que des détails sur les performances sur mobile.</p>
</li>
</ul>
<p>Enfin, certains fabricants développent des pilotes Vulkan open-source pour Linux ; L’étude de ces sources peut aider à mieux comprendre les performances de certaines implémentations de Vulkan :</p>
<ul>
<li>
<p><a href="https://github.com/GPUOpen-Drivers/">GPUOpen-Drivers</a> for AMD — contient <em>xgl</em> qui contient lui-même la source du pilote Vulkan, et <em>PAL</em> qui est une bibliothèque utilisée par <em>xgl</em> ; de nombreux appels de fonction Vulkan finissent par passer par <em>xgl</em> et <em>PAL</em>.</p>
</li>
<li>
<p><a href="https://github.com/mesa3d/mesa/tree/master/src/amd/vulkan">mesa3d/radv</a> for AMD — contient le pilote open-source développé par la communauté <em>radv</em>.</p>
</li>
<li>
<p><a href="https://github.com/mesa3d/mesa/tree/master/src/intel/vulkan">mesa3d/anvil</a> for Intel — contient le pilote Anvil.</p>
</li>
</ul>
<blockquote>
<p>L’auteur souhaite remercier Alex Smith (Feral Interactive), Daniel Rákos (AMD), Hans-Kristian Arntzen (ex. ARM), Matthäus Chajdas (AMD), Wessam Bahnassi (INFramez Technology Corp) et Wolfgang Engel (CONFETTI) pour la relecture du brouillon de cet article et leur contribution à son amélioration.</p>
</blockquote>
<div class="footnote">
<hr>
<ol>
<li id="fn:1">
<p>Ndt : Le prix original est de 2,99 $, ce qui est en effet moins cher qu’une tasse de café aux États-Unis.&nbsp;<a class="footnote-backref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fnref:1" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:2">
<p>Nous couvrirons uniquement les types d’allocation de mémoire inscriptibles depuis l’hôte et lisibles ou inscriptibles depuis le GPU ; pour la lecture par le CPU des données écrites par GPU, la mémoire avec l’indicateur <code>VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code> est plus appropriée.&nbsp;<a class="footnote-backref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fnref:2" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
<li id="fn:3">
<p>Remarquez que <code>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> implique généralement que la mémoire sera en « écriture combinée » ; sur certains dispositifs, il est possible d’allouer de la mémoire de façon non continue et de la vider avec <code>vkFlushMappedMemoryRanges</code>.&nbsp;<a class="footnote-backref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fnref:3" title="Jump back to footnote 3 in the text">↩</a></p>
</li>
<li id="fn:4">
<p>Notez qu’avec 4 descripteurs par pipeline, cette approche ne peut pas gérer la configuration complète du pipeline pour le VS, GS, TCS et TES — ce qui n’est un problème que si vous utilisez la tesselation sur un pilote n’exposant que 4 sets de descripteurs.&nbsp;<a class="footnote-backref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fnref:4" title="Jump back to footnote 4 in the text">↩</a></p>
</li>
<li id="fn:5">
<p>Suivant l’architecture GPU, il peut également être avantageux de pousser certains index en constante, tel que l’index de matériau ou le décalage des données des sommets, pour diminuer le nombre d’indirections de la mémoire dans les vertex/fragment shaders.&nbsp;<a class="footnote-backref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fnref:5" title="Jump back to footnote 5 in the text">↩</a></p>
</li>
<li id="fn:6">
<p>Malheureusement, Vulkan ne permet pas au pilote d’implémenter l’enregistrement d’un <em>command buffer</em> thread-safe de sorte qu’une seule <em>pool</em> de commandes puisse être réutilisée entre les threads ; dans l’approche décrite, la synchronisation entre les threads n’est nécessaire que pour changer les pages, ce qui est relativement rare et peut être fait sans verrouillage pour la plupart.&nbsp;<a class="footnote-backref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fnref:6" title="Jump back to footnote 6 in the text">↩</a></p>
</li>
<li id="fn:7">
<p>Ndt : Lire « <a href="https://www.reddit.com/r/vulkan/comments/8cwyf8/command_buffer_state_what_else/">Command Buffer State — what else?</a> » pour en savoir plus sur les états des <em>command buffers</em>.&nbsp;<a class="footnote-backref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fnref:7" title="Jump back to footnote 7 in the text">↩</a></p>
</li>
<li id="fn:8">
<p>Ndt : Plus d’information <a href="https://fr.wikipedia.org/wiki/Render_Output_unit">sur la page Wikipédia</a>.&nbsp;<a class="footnote-backref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fnref:8" title="Jump back to footnote 8 in the text">↩</a></p>
</li>
<li id="fn:9">
<p>Il est important de noter qu’une croyance communément admise selon laquelle chaque <em>draw call</em> s’exécutent de manière isolée sans chevauchement avec d’autres travaux est erronée — les GPU exécutent généralement les <em>draw calls</em> qui suivent en parallèle entre l’état de rendu, le shader et même les commutateurs de cible de rendu.&nbsp;<a class="footnote-backref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fnref:9" title="Jump back to footnote 9 in the text">↩</a></p>
</li>
<li id="fn:10">
<p>Bien sûr, rien ne garantit que le pilote effectue cette optimisation — elle dépend de l’architecture du matériel et de l’implémentation du pilote.&nbsp;<a class="footnote-backref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fnref:10" title="Jump back to footnote 10 in the text">↩</a></p>
</li>
<li id="fn:11">
<p>Ndt : Plus d’information sur la notion de « section critique » <a href="https://fr.wikipedia.org/wiki/Section_critique">sur la page Wikipédia</a>.&nbsp;<a class="footnote-backref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fnref:11" title="Jump back to footnote 11 in the text">↩</a></p>
</li>
<li id="fn:12">
<p>Cela peut passer par un format spécifique à l’application, ou une bibliothèque comme <a href="https://github.com/ValveSoftware/Fossilize">Fossilize</a>.&nbsp;<a class="footnote-backref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fnref:12" title="Jump back to footnote 12 in the text">↩</a></p>
</li>
<li id="fn:13">
<p>Ndt : Plus d’information sur la notion de « séparation des préoccupations » <a href="https://fr.wikipedia.org/wiki/S%C3%A9paration_des_pr%C3%A9occupations">sur la page Wikipédia</a>.&nbsp;<a class="footnote-backref" href="https://www.fevrierdorian.com/carnet/pages/ecrire-un-moteur-de-rendu-vulkan-performant.html#fnref:13" title="Jump back to footnote 13 in the text">↩</a></p>
</li>
</ol>
</div>

    </main>
        <footer id="contentinfo" class="body">
            <address id="about" class="vcard body">
            Proudly powered by <a href="https://getpelican.com/">Pelican</a>,
            which takes great advantage of <a href="https://www.python.org/">Python</a>.
            </address><!-- /#about -->
        </footer><!-- /#contentinfo -->

</body></html>